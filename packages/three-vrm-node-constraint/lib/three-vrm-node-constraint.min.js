/*! (c) 2020-2023 pixiv Inc. - https://github.com/pixiv/three-vrm/blob/release/LICENSE */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE_VRM_NODE_CONSTRAINT={},t.THREE)}(this,(function(t,e){"use strict";function n(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(n){if("default"!==n){var s=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,s.get?s:{enumerable:!0,get:function(){return t[n]}})}})),e.default=t,Object.freeze(e)}var s=n(e);const i=new s.Vector3;class o extends s.Group{constructor(t){super(),this._attrPosition=new s.BufferAttribute(new Float32Array([0,0,0,0,0,0]),3),this._attrPosition.setUsage(s.DynamicDrawUsage);const e=new s.BufferGeometry;e.setAttribute("position",this._attrPosition);const n=new s.LineBasicMaterial({color:16711935,depthTest:!1,depthWrite:!1});this._line=new s.Line(e,n),this.add(this._line),this.constraint=t}updateMatrixWorld(t){i.setFromMatrixPosition(this.constraint.destination.matrixWorld),this._attrPosition.setXYZ(0,i.x,i.y,i.z),this.constraint.source&&i.setFromMatrixPosition(this.constraint.source.matrixWorld),this._attrPosition.setXYZ(1,i.x,i.y,i.z),this._attrPosition.needsUpdate=!0,super.updateMatrixWorld(t)}}function r(t,e){return e.set(t.elements[12],t.elements[13],t.elements[14])}const a=new s.Vector3,u=new s.Vector3;function c(t){return t.invert?t.invert():t.inverse(),t}class l{constructor(t,e){this.destination=t,this.source=e,this.weight=1}}const d=new s.Vector3,h=new s.Vector3,p=new s.Vector3,_=new s.Quaternion,f=new s.Quaternion,w=new s.Quaternion;class R extends l{get aimAxis(){return this._aimAxis}set aimAxis(t){this._aimAxis=t,this._v3AimAxis.set("PositiveX"===t?1:"NegativeX"===t?-1:0,"PositiveY"===t?1:"NegativeY"===t?-1:0,"PositiveZ"===t?1:"NegativeZ"===t?-1:0)}get dependencies(){const t=new Set([this.source]);return this.destination.parent&&t.add(this.destination.parent),t}constructor(t,e){super(t,e),this._aimAxis="PositiveX",this._v3AimAxis=new s.Vector3(1,0,0),this._dstRestQuat=new s.Quaternion}setInitState(){this._dstRestQuat.copy(this.destination.quaternion)}update(){this.destination.updateWorldMatrix(!0,!1),this.source.updateWorldMatrix(!0,!1);const t=_.identity(),e=f.identity();var n,s;this.destination.parent&&(n=this.destination.parent.matrixWorld,s=t,n.decompose(a,s,u),c(e.copy(t)));const i=d.copy(this._v3AimAxis).applyQuaternion(this._dstRestQuat).applyQuaternion(t),o=r(this.source.matrixWorld,h).sub(r(this.destination.matrixWorld,p)).normalize(),l=w.setFromUnitVectors(i,o).premultiply(e).multiply(t).multiply(this._dstRestQuat);this.destination.quaternion.copy(this._dstRestQuat).slerp(l,this.weight)}}function m(t,e,n,s){return new(n||(n=Promise))((function(i,o){function r(t){try{u(s.next(t))}catch(t){o(t)}}function a(t){try{u(s.throw(t))}catch(t){o(t)}}function u(t){var e;t.done?i(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(r,a)}u((s=s.apply(t,e||[])).next())}))}function y(t,e){const n=[t];let s=t.parent;for(;null!==s;)n.unshift(s),s=s.parent;n.forEach((t=>{e(t)}))}class v{constructor(){this._constraints=new Set,this._objectConstraintsMap=new Map}get constraints(){return this._constraints}addConstraint(t){this._constraints.add(t);let e=this._objectConstraintsMap.get(t.destination);null==e&&(e=new Set,this._objectConstraintsMap.set(t.destination,e)),e.add(t)}deleteConstraint(t){this._constraints.delete(t);this._objectConstraintsMap.get(t.destination).delete(t)}setInitState(){const t=new Set,e=new Set;for(const n of this._constraints)this._processConstraint(n,t,e,(t=>t.setInitState()))}update(){const t=new Set,e=new Set;for(const n of this._constraints)this._processConstraint(n,t,e,(t=>t.update()))}_processConstraint(t,e,n,s){if(n.has(t))return;if(e.has(t))throw new Error("VRMNodeConstraintManager: Circular dependency detected while updating constraints");e.add(t);const i=t.dependencies;for(const t of i)y(t,(t=>{const i=this._objectConstraintsMap.get(t);if(i)for(const t of i)this._processConstraint(t,e,n,s)}));s(t),n.add(t)}}const x=new s.Quaternion,Q=new s.Quaternion;class g extends l{get dependencies(){return new Set([this.source])}constructor(t,e){super(t,e),this._dstRestQuat=new s.Quaternion,this._invSrcRestQuat=new s.Quaternion}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),c(this._invSrcRestQuat.copy(this.source.quaternion))}update(){const t=x.copy(this._invSrcRestQuat).multiply(this.source.quaternion),e=Q.copy(this._dstRestQuat).multiply(t);this.destination.quaternion.copy(this._dstRestQuat).slerp(e,this.weight)}}const M=new s.Vector3,A=new s.Quaternion,C=new s.Quaternion;class N extends l{get rollAxis(){return this._rollAxis}set rollAxis(t){this._rollAxis=t,this._v3RollAxis.set("X"===t?1:0,"Y"===t?1:0,"Z"===t?1:0)}get dependencies(){return new Set([this.source])}constructor(t,e){super(t,e),this._rollAxis="X",this._v3RollAxis=new s.Vector3(1,0,0),this._dstRestQuat=new s.Quaternion,this._invDstRestQuat=new s.Quaternion,this._invSrcRestQuatMulDstRestQuat=new s.Quaternion}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),c(this._invDstRestQuat.copy(this._dstRestQuat)),c(this._invSrcRestQuatMulDstRestQuat.copy(this.source.quaternion)).multiply(this._dstRestQuat)}update(){const t=A.copy(this._invDstRestQuat).multiply(this.source.quaternion).multiply(this._invSrcRestQuatMulDstRestQuat),e=M.copy(this._v3RollAxis).applyQuaternion(t),n=C.setFromUnitVectors(e,this._v3RollAxis).premultiply(this._dstRestQuat).multiply(t);this.destination.quaternion.copy(this._dstRestQuat).slerp(n,this.weight)}}const S=new Set(["1.0","1.0-beta"]);class E{get name(){return E.EXTENSION_NAME}constructor(t,e){this.parser=t,this.helperRoot=null==e?void 0:e.helperRoot}afterRoot(t){return m(this,void 0,void 0,(function*(){t.userData.vrmNodeConstraintManager=yield this._import(t)}))}_import(t){var e;return m(this,void 0,void 0,(function*(){const n=this.parser.json;if(!(-1!==(null===(e=n.extensionsUsed)||void 0===e?void 0:e.indexOf(E.EXTENSION_NAME))))return null;const s=new v,i=yield this.parser.getDependencies("node");return i.forEach(((t,e)=>{var o;const r=n.nodes[e],a=null===(o=null==r?void 0:r.extensions)||void 0===o?void 0:o[E.EXTENSION_NAME];if(null==a)return;const u=a.specVersion;if(!S.has(u))return void console.warn(`VRMNodeConstraintLoaderPlugin: Unknown ${E.EXTENSION_NAME} specVersion "${u}"`);const c=a.constraint;if(null!=c.roll){const e=this._importRollConstraint(t,i,c.roll);s.addConstraint(e)}else if(null!=c.aim){const e=this._importAimConstraint(t,i,c.aim);s.addConstraint(e)}else if(null!=c.rotation){const e=this._importRotationConstraint(t,i,c.rotation);s.addConstraint(e)}})),t.scene.updateMatrixWorld(),s.setInitState(),s}))}_importRollConstraint(t,e,n){const{source:s,rollAxis:i,weight:r}=n,a=e[s],u=new N(t,a);if(null!=i&&(u.rollAxis=i),null!=r&&(u.weight=r),this.helperRoot){const t=new o(u);this.helperRoot.add(t)}return u}_importAimConstraint(t,e,n){const{source:s,aimAxis:i,weight:r}=n,a=e[s],u=new R(t,a);if(null!=i&&(u.aimAxis=i),null!=r&&(u.weight=r),this.helperRoot){const t=new o(u);this.helperRoot.add(t)}return u}_importRotationConstraint(t,e,n){const{source:s,weight:i}=n,r=e[s],a=new g(t,r);if(null!=i&&(a.weight=i),this.helperRoot){const t=new o(a);this.helperRoot.add(t)}return a}}E.EXTENSION_NAME="VRMC_node_constraint",t.VRMAimConstraint=R,t.VRMNodeConstraint=l,t.VRMNodeConstraintHelper=o,t.VRMNodeConstraintLoaderPlugin=E,t.VRMNodeConstraintManager=v,t.VRMRollConstraint=N,t.VRMRotationConstraint=g,Object.defineProperty(t,"__esModule",{value:!0}),Object.assign(e,t)}));
