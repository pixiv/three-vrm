/*! (c) 2019-2024 pixiv Inc. - https://github.com/pixiv/three-vrm/blob/release/LICENSE */
var w=(n,t,e)=>new Promise((i,o)=>{var r=s=>{try{a(e.next(s))}catch(p){o(p)}},c=s=>{try{a(e.throw(s))}catch(p){o(p)}},a=s=>s.done?i(s.value):Promise.resolve(s.value).then(r,c);a((e=e.apply(n,t)).next())});import*as u from"three";var R=new u.Vector3,h=class extends u.Group{constructor(t){super(),this._attrPosition=new u.BufferAttribute(new Float32Array([0,0,0,0,0,0]),3),this._attrPosition.setUsage(u.DynamicDrawUsage);let e=new u.BufferGeometry;e.setAttribute("position",this._attrPosition);let i=new u.LineBasicMaterial({color:16711935,depthTest:!1,depthWrite:!1});this._line=new u.Line(e,i),this.add(this._line),this.constraint=t}updateMatrixWorld(t){R.setFromMatrixPosition(this.constraint.destination.matrixWorld),this._attrPosition.setXYZ(0,R.x,R.y,R.z),this.constraint.source&&R.setFromMatrixPosition(this.constraint.source.matrixWorld),this._attrPosition.setXYZ(1,R.x,R.y,R.z),this._attrPosition.needsUpdate=!0,super.updateMatrixWorld(t)}};import*as d from"three";function Q(n,t){return t.set(n.elements[12],n.elements[13],n.elements[14])}import*as N from"three";var j=new N.Vector3,A=new N.Vector3;function g(n,t){return n.decompose(j,t,A),t}function m(n){return n.invert?n.invert():n.inverse(),n}var l=class{constructor(t,e){this.destination=t,this.source=e,this.weight=1}};var O=new d.Vector3,P=new d.Vector3,q=new d.Vector3,L=new d.Quaternion,F=new d.Quaternion,I=new d.Quaternion,f=class extends l{get aimAxis(){return this._aimAxis}set aimAxis(t){this._aimAxis=t,this._v3AimAxis.set(t==="PositiveX"?1:t==="NegativeX"?-1:0,t==="PositiveY"?1:t==="NegativeY"?-1:0,t==="PositiveZ"?1:t==="NegativeZ"?-1:0)}get dependencies(){let t=new Set([this.source]);return this.destination.parent&&t.add(this.destination.parent),t}constructor(t,e){super(t,e),this._aimAxis="PositiveX",this._v3AimAxis=new d.Vector3(1,0,0),this._dstRestQuat=new d.Quaternion}setInitState(){this._dstRestQuat.copy(this.destination.quaternion)}update(){this.destination.updateWorldMatrix(!0,!1),this.source.updateWorldMatrix(!0,!1);let t=L.identity(),e=F.identity();this.destination.parent&&(g(this.destination.parent.matrixWorld,t),m(e.copy(t)));let i=O.copy(this._v3AimAxis).applyQuaternion(this._dstRestQuat).applyQuaternion(t),o=Q(this.source.matrixWorld,P).sub(Q(this.destination.matrixWorld,q)).normalize(),r=I.setFromUnitVectors(i,o).premultiply(e).multiply(t).multiply(this._dstRestQuat);this.destination.quaternion.copy(this._dstRestQuat).slerp(r,this.weight)}};function D(n,t){let e=[n],i=n.parent;for(;i!==null;)e.unshift(i),i=i.parent;e.forEach(o=>{t(o)})}var b=class{constructor(){this._constraints=new Set;this._objectConstraintsMap=new Map}get constraints(){return this._constraints}addConstraint(t){this._constraints.add(t);let e=this._objectConstraintsMap.get(t.destination);e==null&&(e=new Set,this._objectConstraintsMap.set(t.destination,e)),e.add(t)}deleteConstraint(t){this._constraints.delete(t),this._objectConstraintsMap.get(t.destination).delete(t)}setInitState(){let t=new Set,e=new Set;for(let i of this._constraints)this._processConstraint(i,t,e,o=>o.setInitState())}update(){let t=new Set,e=new Set;for(let i of this._constraints)this._processConstraint(i,t,e,o=>o.update())}_processConstraint(t,e,i,o){if(i.has(t))return;if(e.has(t))throw new Error("VRMNodeConstraintManager: Circular dependency detected while updating constraints");e.add(t);let r=t.dependencies;for(let c of r)D(c,a=>{let s=this._objectConstraintsMap.get(a);if(s)for(let p of s)this._processConstraint(p,e,i,o)});o(t),i.add(t)}};import*as H from"three";var X=new H.Quaternion,G=new H.Quaternion,C=class extends l{get dependencies(){return new Set([this.source])}constructor(t,e){super(t,e),this._dstRestQuat=new H.Quaternion,this._invSrcRestQuat=new H.Quaternion}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),m(this._invSrcRestQuat.copy(this.source.quaternion))}update(){let t=X.copy(this._invSrcRestQuat).multiply(this.source.quaternion),e=G.copy(this._dstRestQuat).multiply(t);this.destination.quaternion.copy(this._dstRestQuat).slerp(e,this.weight)}};import*as E from"three";var Y=new E.Vector3,Z=new E.Quaternion,W=new E.Quaternion,x=class extends l{get rollAxis(){return this._rollAxis}set rollAxis(t){this._rollAxis=t,this._v3RollAxis.set(t==="X"?1:0,t==="Y"?1:0,t==="Z"?1:0)}get dependencies(){return new Set([this.source])}constructor(t,e){super(t,e),this._rollAxis="X",this._v3RollAxis=new E.Vector3(1,0,0),this._dstRestQuat=new E.Quaternion,this._invDstRestQuat=new E.Quaternion,this._invSrcRestQuatMulDstRestQuat=new E.Quaternion}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),m(this._invDstRestQuat.copy(this._dstRestQuat)),m(this._invSrcRestQuatMulDstRestQuat.copy(this.source.quaternion)).multiply(this._dstRestQuat)}update(){let t=Z.copy(this._invDstRestQuat).multiply(this.source.quaternion).multiply(this._invSrcRestQuatMulDstRestQuat),e=Y.copy(this._v3RollAxis).applyQuaternion(t),o=W.setFromUnitVectors(e,this._v3RollAxis).premultiply(this._dstRestQuat).multiply(t);this.destination.quaternion.copy(this._dstRestQuat).slerp(o,this.weight)}};var B=new Set(["1.0","1.0-beta"]),T=class T{get name(){return T.EXTENSION_NAME}constructor(t,e){this.parser=t,this.helperRoot=e==null?void 0:e.helperRoot}afterRoot(t){return w(this,null,function*(){t.userData.vrmNodeConstraintManager=yield this._import(t)})}_import(t){return w(this,null,function*(){var c;let e=this.parser.json;if(!(((c=e.extensionsUsed)==null?void 0:c.indexOf(T.EXTENSION_NAME))!==-1))return null;let o=new b,r=yield this.parser.getDependencies("node");return r.forEach((a,s)=>{var y;let p=e.nodes[s],M=(y=p==null?void 0:p.extensions)==null?void 0:y[T.EXTENSION_NAME];if(M==null)return;let S=M.specVersion;if(!B.has(S)){console.warn(`VRMNodeConstraintLoaderPlugin: Unknown ${T.EXTENSION_NAME} specVersion "${S}"`);return}let v=M.constraint;if(v.roll!=null){let _=this._importRollConstraint(a,r,v.roll);o.addConstraint(_)}else if(v.aim!=null){let _=this._importAimConstraint(a,r,v.aim);o.addConstraint(_)}else if(v.rotation!=null){let _=this._importRotationConstraint(a,r,v.rotation);o.addConstraint(_)}}),t.scene.updateMatrixWorld(),o.setInitState(),o})}_importRollConstraint(t,e,i){let{source:o,rollAxis:r,weight:c}=i,a=e[o],s=new x(t,a);if(r!=null&&(s.rollAxis=r),c!=null&&(s.weight=c),this.helperRoot){let p=new h(s);this.helperRoot.add(p)}return s}_importAimConstraint(t,e,i){let{source:o,aimAxis:r,weight:c}=i,a=e[o],s=new f(t,a);if(r!=null&&(s.aimAxis=r),c!=null&&(s.weight=c),this.helperRoot){let p=new h(s);this.helperRoot.add(p)}return s}_importRotationConstraint(t,e,i){let{source:o,weight:r}=i,c=e[o],a=new C(t,c);if(r!=null&&(a.weight=r),this.helperRoot){let s=new h(a);this.helperRoot.add(s)}return a}};T.EXTENSION_NAME="VRMC_node_constraint";var V=T;export{f as VRMAimConstraint,l as VRMNodeConstraint,h as VRMNodeConstraintHelper,V as VRMNodeConstraintLoaderPlugin,b as VRMNodeConstraintManager,x as VRMRollConstraint,C as VRMRotationConstraint};
