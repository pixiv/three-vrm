/*! (c) 2020-2023 pixiv Inc. - https://github.com/pixiv/three-vrm/blob/release/LICENSE */
import*as t from"three";const e=new t.Vector3;class s extends t.Group{constructor(e){super(),this._attrPosition=new t.BufferAttribute(new Float32Array([0,0,0,0,0,0]),3),this._attrPosition.setUsage(t.DynamicDrawUsage);const s=new t.BufferGeometry;s.setAttribute("position",this._attrPosition);const n=new t.LineBasicMaterial({color:16711935,depthTest:!1,depthWrite:!1});this._line=new t.Line(s,n),this.add(this._line),this.constraint=e}updateMatrixWorld(t){e.setFromMatrixPosition(this.constraint.destination.matrixWorld),this._attrPosition.setXYZ(0,e.x,e.y,e.z),this.constraint.source&&e.setFromMatrixPosition(this.constraint.source.matrixWorld),this._attrPosition.setXYZ(1,e.x,e.y,e.z),this._attrPosition.needsUpdate=!0,super.updateMatrixWorld(t)}}function n(t,e){return e.set(t.elements[12],t.elements[13],t.elements[14])}const i=new t.Vector3,o=new t.Vector3;function r(t){return t.invert?t.invert():t.inverse(),t}class a{constructor(t,e){this.destination=t,this.source=e,this.weight=1}}const u=new t.Vector3,c=new t.Vector3,l=new t.Vector3,h=new t.Quaternion,d=new t.Quaternion,p=new t.Quaternion;class _ extends a{get aimAxis(){return this._aimAxis}set aimAxis(t){this._aimAxis=t,this._v3AimAxis.set("PositiveX"===t?1:"NegativeX"===t?-1:0,"PositiveY"===t?1:"NegativeY"===t?-1:0,"PositiveZ"===t?1:"NegativeZ"===t?-1:0)}get dependencies(){const t=new Set([this.source]);return this.destination.parent&&t.add(this.destination.parent),t}constructor(e,s){super(e,s),this._aimAxis="PositiveX",this._v3AimAxis=new t.Vector3(1,0,0),this._dstRestQuat=new t.Quaternion}setInitState(){this._dstRestQuat.copy(this.destination.quaternion)}update(){this.destination.updateWorldMatrix(!0,!1),this.source.updateWorldMatrix(!0,!1);const t=h.identity(),e=d.identity();var s,a;this.destination.parent&&(s=this.destination.parent.matrixWorld,a=t,s.decompose(i,a,o),r(e.copy(t)));const _=u.copy(this._v3AimAxis).applyQuaternion(this._dstRestQuat).applyQuaternion(t),w=n(this.source.matrixWorld,c).sub(n(this.destination.matrixWorld,l)).normalize(),m=p.setFromUnitVectors(_,w).premultiply(e).multiply(t).multiply(this._dstRestQuat);this.destination.quaternion.copy(this._dstRestQuat).slerp(m,this.weight)}}function w(t,e,s,n){return new(s||(s=Promise))((function(i,o){function r(t){try{u(n.next(t))}catch(t){o(t)}}function a(t){try{u(n.throw(t))}catch(t){o(t)}}function u(t){var e;t.done?i(t.value):(e=t.value,e instanceof s?e:new s((function(t){t(e)}))).then(r,a)}u((n=n.apply(t,e||[])).next())}))}function m(t,e){const s=[t];let n=t.parent;for(;null!==n;)s.unshift(n),n=n.parent;s.forEach((t=>{e(t)}))}class R{constructor(){this._constraints=new Set,this._objectConstraintsMap=new Map}get constraints(){return this._constraints}addConstraint(t){this._constraints.add(t);let e=this._objectConstraintsMap.get(t.destination);null==e&&(e=new Set,this._objectConstraintsMap.set(t.destination,e)),e.add(t)}deleteConstraint(t){this._constraints.delete(t);this._objectConstraintsMap.get(t.destination).delete(t)}setInitState(){const t=new Set,e=new Set;for(const s of this._constraints)this._processConstraint(s,t,e,(t=>t.setInitState()))}update(){const t=new Set,e=new Set;for(const s of this._constraints)this._processConstraint(s,t,e,(t=>t.update()))}_processConstraint(t,e,s,n){if(s.has(t))return;if(e.has(t))throw new Error("VRMNodeConstraintManager: Circular dependency detected while updating constraints");e.add(t);const i=t.dependencies;for(const t of i)m(t,(t=>{const i=this._objectConstraintsMap.get(t);if(i)for(const t of i)this._processConstraint(t,e,s,n)}));n(t),s.add(t)}}const x=new t.Quaternion,v=new t.Quaternion;class f extends a{get dependencies(){return new Set([this.source])}constructor(e,s){super(e,s),this._dstRestQuat=new t.Quaternion,this._invSrcRestQuat=new t.Quaternion}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),r(this._invSrcRestQuat.copy(this.source.quaternion))}update(){const t=x.copy(this._invSrcRestQuat).multiply(this.source.quaternion),e=v.copy(this._dstRestQuat).multiply(t);this.destination.quaternion.copy(this._dstRestQuat).slerp(e,this.weight)}}const Q=new t.Vector3,y=new t.Quaternion,A=new t.Quaternion;class g extends a{get rollAxis(){return this._rollAxis}set rollAxis(t){this._rollAxis=t,this._v3RollAxis.set("X"===t?1:0,"Y"===t?1:0,"Z"===t?1:0)}get dependencies(){return new Set([this.source])}constructor(e,s){super(e,s),this._rollAxis="X",this._v3RollAxis=new t.Vector3(1,0,0),this._dstRestQuat=new t.Quaternion,this._invDstRestQuat=new t.Quaternion,this._invSrcRestQuatMulDstRestQuat=new t.Quaternion}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),r(this._invDstRestQuat.copy(this._dstRestQuat)),r(this._invSrcRestQuatMulDstRestQuat.copy(this.source.quaternion)).multiply(this._dstRestQuat)}update(){const t=y.copy(this._invDstRestQuat).multiply(this.source.quaternion).multiply(this._invSrcRestQuatMulDstRestQuat),e=Q.copy(this._v3RollAxis).applyQuaternion(t),s=A.setFromUnitVectors(e,this._v3RollAxis).premultiply(this._dstRestQuat).multiply(t);this.destination.quaternion.copy(this._dstRestQuat).slerp(s,this.weight)}}const M=new Set(["1.0","1.0-beta"]);class S{get name(){return S.EXTENSION_NAME}constructor(t,e){this.parser=t,this.helperRoot=null==e?void 0:e.helperRoot}afterRoot(t){return w(this,void 0,void 0,(function*(){t.userData.vrmNodeConstraintManager=yield this._import(t)}))}_import(t){var e;return w(this,void 0,void 0,(function*(){const s=this.parser.json;if(!(-1!==(null===(e=s.extensionsUsed)||void 0===e?void 0:e.indexOf(S.EXTENSION_NAME))))return null;const n=new R,i=yield this.parser.getDependencies("node");return i.forEach(((t,e)=>{var o;const r=s.nodes[e],a=null===(o=null==r?void 0:r.extensions)||void 0===o?void 0:o[S.EXTENSION_NAME];if(null==a)return;const u=a.specVersion;if(!M.has(u))return void console.warn(`VRMNodeConstraintLoaderPlugin: Unknown ${S.EXTENSION_NAME} specVersion "${u}"`);const c=a.constraint;if(null!=c.roll){const e=this._importRollConstraint(t,i,c.roll);n.addConstraint(e)}else if(null!=c.aim){const e=this._importAimConstraint(t,i,c.aim);n.addConstraint(e)}else if(null!=c.rotation){const e=this._importRotationConstraint(t,i,c.rotation);n.addConstraint(e)}})),t.scene.updateMatrixWorld(),n.setInitState(),n}))}_importRollConstraint(t,e,n){const{source:i,rollAxis:o,weight:r}=n,a=e[i],u=new g(t,a);if(null!=o&&(u.rollAxis=o),null!=r&&(u.weight=r),this.helperRoot){const t=new s(u);this.helperRoot.add(t)}return u}_importAimConstraint(t,e,n){const{source:i,aimAxis:o,weight:r}=n,a=e[i],u=new _(t,a);if(null!=o&&(u.aimAxis=o),null!=r&&(u.weight=r),this.helperRoot){const t=new s(u);this.helperRoot.add(t)}return u}_importRotationConstraint(t,e,n){const{source:i,weight:o}=n,r=e[i],a=new f(t,r);if(null!=o&&(a.weight=o),this.helperRoot){const t=new s(a);this.helperRoot.add(t)}return a}}S.EXTENSION_NAME="VRMC_node_constraint";export{_ as VRMAimConstraint,a as VRMNodeConstraint,s as VRMNodeConstraintHelper,S as VRMNodeConstraintLoaderPlugin,R as VRMNodeConstraintManager,g as VRMRollConstraint,f as VRMRotationConstraint};
