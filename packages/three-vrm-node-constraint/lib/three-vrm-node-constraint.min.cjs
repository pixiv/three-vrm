/*! (c) 2019-2024 pixiv Inc. - https://github.com/pixiv/three-vrm/blob/release/LICENSE */
"use strict";var P=Object.create;var w=Object.defineProperty;var q=Object.getOwnPropertyDescriptor;var L=Object.getOwnPropertyNames;var F=Object.getPrototypeOf,I=Object.prototype.hasOwnProperty;var X=(o,t)=>{for(var e in t)w(o,e,{get:t[e],enumerable:!0})},j=(o,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of L(t))!I.call(o,i)&&i!==e&&w(o,i,{get:()=>t[i],enumerable:!(s=q(t,i))||s.enumerable});return o};var x=(o,t,e)=>(e=o!=null?P(F(o)):{},j(t||!o||!o.__esModule?w(e,"default",{value:o,enumerable:!0}):e,o)),G=o=>j(w({},"__esModule",{value:!0}),o);var V=(o,t,e)=>new Promise((s,i)=>{var r=n=>{try{a(e.next(n))}catch(p){i(p)}},c=n=>{try{a(e.throw(n))}catch(p){i(p)}},a=n=>n.done?s(n.value):Promise.resolve(n.value).then(r,c);a((e=e.apply(o,t)).next())});var st={};X(st,{VRMAimConstraint:()=>_,VRMNodeConstraint:()=>d,VRMNodeConstraintHelper:()=>h,VRMNodeConstraintLoaderPlugin:()=>Q,VRMNodeConstraintManager:()=>f,VRMRollConstraint:()=>H,VRMRotationConstraint:()=>b});module.exports=G(st);var u=x(require("three"),1),R=new u.Vector3,h=class extends u.Group{constructor(t){super(),this._attrPosition=new u.BufferAttribute(new Float32Array([0,0,0,0,0,0]),3),this._attrPosition.setUsage(u.DynamicDrawUsage);let e=new u.BufferGeometry;e.setAttribute("position",this._attrPosition);let s=new u.LineBasicMaterial({color:16711935,depthTest:!1,depthWrite:!1});this._line=new u.Line(e,s),this.add(this._line),this.constraint=t}updateMatrixWorld(t){R.setFromMatrixPosition(this.constraint.destination.matrixWorld),this._attrPosition.setXYZ(0,R.x,R.y,R.z),this.constraint.source&&R.setFromMatrixPosition(this.constraint.source.matrixWorld),this._attrPosition.setXYZ(1,R.x,R.y,R.z),this._attrPosition.needsUpdate=!0,super.updateMatrixWorld(t)}};var l=x(require("three"),1);function S(o,t){return t.set(o.elements[12],o.elements[13],o.elements[14])}var y=x(require("three"),1),Y=new y.Vector3,Z=new y.Vector3;function A(o,t){return o.decompose(Y,t,Z),t}function m(o){return o.invert?o.invert():o.inverse(),o}var d=class{constructor(t,e){this.destination=t,this.source=e,this.weight=1}};var W=new l.Vector3,B=new l.Vector3,U=new l.Vector3,z=new l.Quaternion,$=new l.Quaternion,k=new l.Quaternion,_=class extends d{get aimAxis(){return this._aimAxis}set aimAxis(t){this._aimAxis=t,this._v3AimAxis.set(t==="PositiveX"?1:t==="NegativeX"?-1:0,t==="PositiveY"?1:t==="NegativeY"?-1:0,t==="PositiveZ"?1:t==="NegativeZ"?-1:0)}get dependencies(){let t=new Set([this.source]);return this.destination.parent&&t.add(this.destination.parent),t}constructor(t,e){super(t,e),this._aimAxis="PositiveX",this._v3AimAxis=new l.Vector3(1,0,0),this._dstRestQuat=new l.Quaternion}setInitState(){this._dstRestQuat.copy(this.destination.quaternion)}update(){this.destination.updateWorldMatrix(!0,!1),this.source.updateWorldMatrix(!0,!1);let t=z.identity(),e=$.identity();this.destination.parent&&(A(this.destination.parent.matrixWorld,t),m(e.copy(t)));let s=W.copy(this._v3AimAxis).applyQuaternion(this._dstRestQuat).applyQuaternion(t),i=S(this.source.matrixWorld,B).sub(S(this.destination.matrixWorld,U)).normalize(),r=k.setFromUnitVectors(s,i).premultiply(e).multiply(t).multiply(this._dstRestQuat);this.destination.quaternion.copy(this._dstRestQuat).slerp(r,this.weight)}};function O(o,t){let e=[o],s=o.parent;for(;s!==null;)e.unshift(s),s=s.parent;e.forEach(i=>{t(i)})}var f=class{constructor(){this._constraints=new Set;this._objectConstraintsMap=new Map}get constraints(){return this._constraints}addConstraint(t){this._constraints.add(t);let e=this._objectConstraintsMap.get(t.destination);e==null&&(e=new Set,this._objectConstraintsMap.set(t.destination,e)),e.add(t)}deleteConstraint(t){this._constraints.delete(t),this._objectConstraintsMap.get(t.destination).delete(t)}setInitState(){let t=new Set,e=new Set;for(let s of this._constraints)this._processConstraint(s,t,e,i=>i.setInitState())}update(){let t=new Set,e=new Set;for(let s of this._constraints)this._processConstraint(s,t,e,i=>i.update())}_processConstraint(t,e,s,i){if(s.has(t))return;if(e.has(t))throw new Error("VRMNodeConstraintManager: Circular dependency detected while updating constraints");e.add(t);let r=t.dependencies;for(let c of r)O(c,a=>{let n=this._objectConstraintsMap.get(a);if(n)for(let p of n)this._processConstraint(p,e,s,i)});i(t),s.add(t)}};var M=x(require("three"),1);var J=new M.Quaternion,K=new M.Quaternion,b=class extends d{get dependencies(){return new Set([this.source])}constructor(t,e){super(t,e),this._dstRestQuat=new M.Quaternion,this._invSrcRestQuat=new M.Quaternion}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),m(this._invSrcRestQuat.copy(this.source.quaternion))}update(){let t=J.copy(this._invSrcRestQuat).multiply(this.source.quaternion),e=K.copy(this._dstRestQuat).multiply(t);this.destination.quaternion.copy(this._dstRestQuat).slerp(e,this.weight)}};var E=x(require("three"),1);var tt=new E.Vector3,et=new E.Quaternion,ot=new E.Quaternion,H=class extends d{get rollAxis(){return this._rollAxis}set rollAxis(t){this._rollAxis=t,this._v3RollAxis.set(t==="X"?1:0,t==="Y"?1:0,t==="Z"?1:0)}get dependencies(){return new Set([this.source])}constructor(t,e){super(t,e),this._rollAxis="X",this._v3RollAxis=new E.Vector3(1,0,0),this._dstRestQuat=new E.Quaternion,this._invDstRestQuat=new E.Quaternion,this._invSrcRestQuatMulDstRestQuat=new E.Quaternion}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),m(this._invDstRestQuat.copy(this._dstRestQuat)),m(this._invSrcRestQuatMulDstRestQuat.copy(this.source.quaternion)).multiply(this._dstRestQuat)}update(){let t=et.copy(this._invDstRestQuat).multiply(this.source.quaternion).multiply(this._invSrcRestQuatMulDstRestQuat),e=tt.copy(this._v3RollAxis).applyQuaternion(t),i=ot.setFromUnitVectors(e,this._v3RollAxis).premultiply(this._dstRestQuat).multiply(t);this.destination.quaternion.copy(this._dstRestQuat).slerp(i,this.weight)}};var it=new Set(["1.0","1.0-beta"]),T=class T{get name(){return T.EXTENSION_NAME}constructor(t,e){this.parser=t,this.helperRoot=e==null?void 0:e.helperRoot}afterRoot(t){return V(this,null,function*(){t.userData.vrmNodeConstraintManager=yield this._import(t)})}_import(t){return V(this,null,function*(){var c;let e=this.parser.json;if(!(((c=e.extensionsUsed)==null?void 0:c.indexOf(T.EXTENSION_NAME))!==-1))return null;let i=new f,r=yield this.parser.getDependencies("node");return r.forEach((a,n)=>{var D;let p=e.nodes[n],N=(D=p==null?void 0:p.extensions)==null?void 0:D[T.EXTENSION_NAME];if(N==null)return;let g=N.specVersion;if(!it.has(g)){console.warn(`VRMNodeConstraintLoaderPlugin: Unknown ${T.EXTENSION_NAME} specVersion "${g}"`);return}let v=N.constraint;if(v.roll!=null){let C=this._importRollConstraint(a,r,v.roll);i.addConstraint(C)}else if(v.aim!=null){let C=this._importAimConstraint(a,r,v.aim);i.addConstraint(C)}else if(v.rotation!=null){let C=this._importRotationConstraint(a,r,v.rotation);i.addConstraint(C)}}),t.scene.updateMatrixWorld(),i.setInitState(),i})}_importRollConstraint(t,e,s){let{source:i,rollAxis:r,weight:c}=s,a=e[i],n=new H(t,a);if(r!=null&&(n.rollAxis=r),c!=null&&(n.weight=c),this.helperRoot){let p=new h(n);this.helperRoot.add(p)}return n}_importAimConstraint(t,e,s){let{source:i,aimAxis:r,weight:c}=s,a=e[i],n=new _(t,a);if(r!=null&&(n.aimAxis=r),c!=null&&(n.weight=c),this.helperRoot){let p=new h(n);this.helperRoot.add(p)}return n}_importRotationConstraint(t,e,s){let{source:i,weight:r}=s,c=e[i],a=new b(t,c);if(r!=null&&(a.weight=r),this.helperRoot){let n=new h(a);this.helperRoot.add(n)}return a}};T.EXTENSION_NAME="VRMC_node_constraint";var Q=T;
