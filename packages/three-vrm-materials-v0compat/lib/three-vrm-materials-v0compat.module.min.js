/*! (c) 2020-2023 pixiv Inc. - https://github.com/pixiv/three-vrm/blob/release/LICENSE */
import*as e from"three";function o(e,o,i,t){return new(i||(i=Promise))((function(r,n){function l(e){try{a(t.next(e))}catch(e){n(e)}}function s(e){try{a(t.throw(e))}catch(e){n(e)}}function a(e){var o;e.done?r(e.value):(o=e.value,o instanceof i?o:new i((function(e){e(o)}))).then(l,s)}a((t=t.apply(e,o||[])).next())}))}function i(e){return Math.pow(e,2.2)}class t{get name(){return"VRMMaterialsV0CompatPlugin"}constructor(e){var o;this.parser=e,this._renderQueueMapTransparent=new Map,this._renderQueueMapTransparentZWrite=new Map;const i=this.parser.json;i.extensionsUsed=null!==(o=i.extensionsUsed)&&void 0!==o?o:[],-1===i.extensionsUsed.indexOf("KHR_texture_transform")&&i.extensionsUsed.push("KHR_texture_transform")}beforeRoot(){var e;return o(this,void 0,void 0,(function*(){const o=this.parser.json,i=null===(e=o.extensions)||void 0===e?void 0:e.VRM,t=null==i?void 0:i.materialProperties;t&&(this._populateRenderQueueMap(t),t.forEach(((e,i)=>{var t,r;const n=null===(t=o.materials)||void 0===t?void 0:t[i];if(null!=n)if("VRM/MToon"===e.shader){const t=this._parseV0MToonProperties(e,n);o.materials[i]=t}else if(null===(r=e.shader)||void 0===r?void 0:r.startsWith("VRM/Unlit")){const t=this._parseV0UnlitProperties(e,n);o.materials[i]=t}else"VRM_USE_GLTFSHADER"===e.shader||console.warn(`VRMMaterialsV0CompatPlugin: Unknown shader: ${e.shader}`);else console.warn(`VRMMaterialsV0CompatPlugin: Attempt to use materials[${i}] of glTF but the material doesn't exist`)})))}))}_parseV0MToonProperties(o,t){var r,n,l,s,a,d,u,v,p,c,h,m,_,f,M,x,P,T,R,g,C,V,O,b,A,F,S,w,y,U,W,E,L,Q,j,N,Z,H,k,B,z,D,q,K;const $=null!==(n=null===(r=o.keywordMap)||void 0===r?void 0:r._ALPHABLEND_ON)&&void 0!==n&&n,I=1===(null===(l=o.floatProperties)||void 0===l?void 0:l._ZWrite)&&$,X=this._v0ParseRenderQueue(o),Y=null!==(a=null===(s=o.keywordMap)||void 0===s?void 0:s._ALPHATEST_ON)&&void 0!==a&&a,G=$?"BLEND":Y?"MASK":"OPAQUE",J=Y?null===(d=o.floatProperties)||void 0===d?void 0:d._Cutoff:void 0,ee=0===(null!==(v=null===(u=o.floatProperties)||void 0===u?void 0:u._CullMode)&&void 0!==v?v:2),oe=this._portTextureTransform(o),ie=null===(c=null===(p=o.vectorProperties)||void 0===p?void 0:p._Color)||void 0===c?void 0:c.map(((e,o)=>3===o?e:i(e))),te=null===(h=o.textureProperties)||void 0===h?void 0:h._MainTex,re=null!=te?{index:te,extensions:Object.assign({},oe)}:void 0,ne=null===(m=o.floatProperties)||void 0===m?void 0:m._BumpScale,le=null===(_=o.textureProperties)||void 0===_?void 0:_._BumpMap,se=null!=le?{index:le,scale:ne,extensions:Object.assign({},oe)}:void 0,ae=null===(M=null===(f=o.vectorProperties)||void 0===f?void 0:f._EmissionColor)||void 0===M?void 0:M.map(i),de=null===(x=o.textureProperties)||void 0===x?void 0:x._EmissionMap,ue=null!=de?{index:de,extensions:Object.assign({},oe)}:void 0,ve=null===(T=null===(P=o.vectorProperties)||void 0===P?void 0:P._ShadeColor)||void 0===T?void 0:T.map(i),pe=null===(R=o.textureProperties)||void 0===R?void 0:R._ShadeTexture,ce=null!=pe?{index:pe,extensions:Object.assign({},oe)}:void 0;let he=null!==(C=null===(g=o.floatProperties)||void 0===g?void 0:g._ShadeShift)&&void 0!==C?C:0,me=null!==(O=null===(V=o.floatProperties)||void 0===V?void 0:V._ShadeToony)&&void 0!==O?O:.9;me=e.MathUtils.lerp(me,1,.5+.5*he),he=-he-(1-me);const _e=null===(b=o.floatProperties)||void 0===b?void 0:b._IndirectLightIntensity,fe=_e?1-_e:void 0,Me=null===(A=o.textureProperties)||void 0===A?void 0:A._SphereAdd,xe=null!=Me?[1,1,1]:void 0,Pe=null!=Me?{index:Me}:void 0,Te=null===(F=o.floatProperties)||void 0===F?void 0:F._RimLightingMix,Re=null===(S=o.textureProperties)||void 0===S?void 0:S._RimTexture,ge=null!=Re?{index:Re,extensions:Object.assign({},oe)}:void 0,Ce=null===(y=null===(w=o.vectorProperties)||void 0===w?void 0:w._RimColor)||void 0===y?void 0:y.map(i),Ve=null===(U=o.floatProperties)||void 0===U?void 0:U._RimFresnelPower,Oe=null===(W=o.floatProperties)||void 0===W?void 0:W._RimLift,be=["none","worldCoordinates","screenCoordinates"][null!==(L=null===(E=o.floatProperties)||void 0===E?void 0:E._OutlineWidthMode)&&void 0!==L?L:0];let Ae=null!==(j=null===(Q=o.floatProperties)||void 0===Q?void 0:Q._OutlineWidth)&&void 0!==j?j:0;Ae*=.01;const Fe=null===(N=o.textureProperties)||void 0===N?void 0:N._OutlineWidthTexture,Se=null!=Fe?{index:Fe,extensions:Object.assign({},oe)}:void 0,we=null===(H=null===(Z=o.vectorProperties)||void 0===Z?void 0:Z._OutlineColor)||void 0===H?void 0:H.map(i),ye=1===(null===(k=o.floatProperties)||void 0===k?void 0:k._OutlineColorMode)?null===(B=o.floatProperties)||void 0===B?void 0:B._OutlineLightingMix:0,Ue=null===(z=o.textureProperties)||void 0===z?void 0:z._UvAnimMaskTexture,We=null!=Ue?{index:Ue,extensions:Object.assign({},oe)}:void 0,Ee=null===(D=o.floatProperties)||void 0===D?void 0:D._UvAnimScrollX;let Le=null===(q=o.floatProperties)||void 0===q?void 0:q._UvAnimScrollY;null!=Le&&(Le=-Le);const Qe={specVersion:"1.0",transparentWithZWrite:I,renderQueueOffsetNumber:X,shadeColorFactor:ve,shadeMultiplyTexture:ce,shadingShiftFactor:he,shadingToonyFactor:me,giEqualizationFactor:fe,matcapFactor:xe,matcapTexture:Pe,rimLightingMixFactor:Te,rimMultiplyTexture:ge,parametricRimColorFactor:Ce,parametricRimFresnelPowerFactor:Ve,parametricRimLiftFactor:Oe,outlineWidthMode:be,outlineWidthFactor:Ae,outlineWidthMultiplyTexture:Se,outlineColorFactor:we,outlineLightingMixFactor:ye,uvAnimationMaskTexture:We,uvAnimationScrollXSpeedFactor:Ee,uvAnimationScrollYSpeedFactor:Le,uvAnimationRotationSpeedFactor:null===(K=o.floatProperties)||void 0===K?void 0:K._UvAnimRotation};return Object.assign(Object.assign({},t),{pbrMetallicRoughness:{baseColorFactor:ie,baseColorTexture:re},normalTexture:se,emissiveTexture:ue,emissiveFactor:ae,alphaMode:G,alphaCutoff:J,doubleSided:ee,extensions:{VRMC_materials_mtoon:Qe}})}_parseV0UnlitProperties(e,o){var t,r,n,l;const s="VRM/UnlitTransparentZWrite"===e.shader,a="VRM/UnlitTransparent"===e.shader||s,d=this._v0ParseRenderQueue(e),u="VRM/UnlitCutout"===e.shader,v=a?"BLEND":u?"MASK":"OPAQUE",p=u?null===(t=e.floatProperties)||void 0===t?void 0:t._Cutoff:void 0,c=this._portTextureTransform(e),h=null===(n=null===(r=e.vectorProperties)||void 0===r?void 0:r._Color)||void 0===n?void 0:n.map(i),m=null===(l=e.textureProperties)||void 0===l?void 0:l._MainTex,_=null!=m?{index:m,extensions:Object.assign({},c)}:void 0,f={specVersion:"1.0",transparentWithZWrite:s,renderQueueOffsetNumber:d,shadeColorFactor:h,shadeMultiplyTexture:_};return Object.assign(Object.assign({},o),{pbrMetallicRoughness:{baseColorFactor:h,baseColorTexture:_},alphaMode:v,alphaCutoff:p,extensions:{VRMC_materials_mtoon:f}})}_portTextureTransform(e){var o,i,t,r,n;const l=null===(o=e.vectorProperties)||void 0===o?void 0:o._MainTex;if(null==l)return{};const s=[null!==(i=null==l?void 0:l[0])&&void 0!==i?i:0,null!==(t=null==l?void 0:l[1])&&void 0!==t?t:0],a=[null!==(r=null==l?void 0:l[2])&&void 0!==r?r:1,null!==(n=null==l?void 0:l[3])&&void 0!==n?n:1];return s[1]=1-a[1]-s[1],{KHR_texture_transform:{offset:s,scale:a}}}_v0ParseRenderQueue(e){var o,i,t;const r=null!==(i=null===(o=e.keywordMap)||void 0===o?void 0:o._ALPHABLEND_ON)&&void 0!==i&&i,n=1===(null===(t=e.floatProperties)||void 0===t?void 0:t._ZWrite);let l=0;if(r){const o=e.renderQueue;null!=o&&(l=n?this._renderQueueMapTransparentZWrite.get(o):this._renderQueueMapTransparent.get(o))}return l}_populateRenderQueueMap(e){const o=new Set,i=new Set;e.forEach((e=>{var t,r,n;const l=null!==(r=null===(t=e.keywordMap)||void 0===t?void 0:t._ALPHABLEND_ON)&&void 0!==r&&r,s=1===(null===(n=e.floatProperties)||void 0===n?void 0:n._ZWrite);if(l){const t=e.renderQueue;null!=t&&(s?i.add(t):o.add(t))}})),o.size>10&&console.warn(`VRMMaterialsV0CompatPlugin: This VRM uses ${o.size} render queues for Transparent materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`),i.size>10&&console.warn(`VRMMaterialsV0CompatPlugin: This VRM uses ${i.size} render queues for TransparentZWrite materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`),Array.from(o).sort().forEach(((e,i)=>{const t=Math.min(Math.max(i-o.size+1,-9),0);this._renderQueueMapTransparent.set(e,t)})),Array.from(i).sort().forEach(((e,o)=>{const i=Math.min(Math.max(o,0),9);this._renderQueueMapTransparentZWrite.set(e,i)}))}}export{t as VRMMaterialsV0CompatPlugin};
