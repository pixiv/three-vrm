## API Report File for "@pixiv/three-vrm"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { GLTF } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { GLTFLoaderPlugin } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';
import * as THREE_2 from 'three';

// @public
export class MToonMaterial extends THREE_2.ShaderMaterial {
    constructor(parameters?: MToonMaterialParameters);
    // (undocumented)
    get color(): THREE_2.Color;
    set color(value: THREE_2.Color);
    // (undocumented)
    copy(source: this): this;
    get debugMode(): MToonMaterialDebugMode;
    set debugMode(m: MToonMaterialDebugMode);
    // (undocumented)
    get emissive(): THREE_2.Color;
    set emissive(value: THREE_2.Color);
    // (undocumented)
    get emissiveIntensity(): number;
    set emissiveIntensity(value: number);
    // (undocumented)
    get emissiveMap(): THREE_2.Texture | null;
    set emissiveMap(value: THREE_2.Texture | null);
    fog: boolean;
    // (undocumented)
    get giEqualizationFactor(): number;
    set giEqualizationFactor(value: number);
    get ignoreVertexColor(): boolean;
    set ignoreVertexColor(value: boolean);
    get isMToonMaterial(): true;
    // (undocumented)
    get isOutline(): boolean;
    set isOutline(b: boolean);
    // (undocumented)
    get map(): THREE_2.Texture | null;
    set map(value: THREE_2.Texture | null);
    // (undocumented)
    get matcapFactor(): THREE_2.Color;
    set matcapFactor(value: THREE_2.Color);
    // (undocumented)
    get matcapTexture(): THREE_2.Texture | null;
    set matcapTexture(value: THREE_2.Texture | null);
    // (undocumented)
    get normalMap(): THREE_2.Texture | null;
    set normalMap(value: THREE_2.Texture | null);
    normalMapType: 0;
    // (undocumented)
    get normalScale(): THREE_2.Vector2;
    set normalScale(value: THREE_2.Vector2);
    // (undocumented)
    get outlineColorFactor(): THREE_2.Color;
    set outlineColorFactor(value: THREE_2.Color);
    // (undocumented)
    get outlineLightingMixFactor(): number;
    set outlineLightingMixFactor(value: number);
    // (undocumented)
    get outlineWidthFactor(): number;
    set outlineWidthFactor(value: number);
    // (undocumented)
    get outlineWidthMode(): MToonMaterialOutlineWidthMode;
    set outlineWidthMode(m: MToonMaterialOutlineWidthMode);
    // (undocumented)
    get outlineWidthMultiplyTexture(): THREE_2.Texture | null;
    set outlineWidthMultiplyTexture(value: THREE_2.Texture | null);
    // (undocumented)
    get parametricRimColorFactor(): THREE_2.Color;
    set parametricRimColorFactor(value: THREE_2.Color);
    // (undocumented)
    get parametricRimFresnelPowerFactor(): number;
    set parametricRimFresnelPowerFactor(value: number);
    // (undocumented)
    get parametricRimLiftFactor(): number;
    set parametricRimLiftFactor(value: number);
    // (undocumented)
    get rimLightingMixFactor(): number;
    set rimLightingMixFactor(value: number);
    // (undocumented)
    get rimMultiplyTexture(): THREE_2.Texture | null;
    set rimMultiplyTexture(value: THREE_2.Texture | null);
    // (undocumented)
    get shadeColorFactor(): THREE_2.Color;
    set shadeColorFactor(value: THREE_2.Color);
    // (undocumented)
    get shadeMultiplyTexture(): THREE_2.Texture | null;
    set shadeMultiplyTexture(value: THREE_2.Texture | null);
    // (undocumented)
    get shadingShiftFactor(): number;
    set shadingShiftFactor(value: number);
    // (undocumented)
    get shadingShiftTexture(): THREE_2.Texture | null;
    set shadingShiftTexture(value: THREE_2.Texture | null);
    // (undocumented)
    get shadingShiftTextureScale(): number;
    set shadingShiftTextureScale(value: number);
    // (undocumented)
    get shadingToonyFactor(): number;
    set shadingToonyFactor(value: number);
    // (undocumented)
    uniforms: {
        litFactor: THREE_2.IUniform<THREE_2.Color>;
        alphaTest: THREE_2.IUniform<number>;
        opacity: THREE_2.IUniform<number>;
        map: THREE_2.IUniform<THREE_2.Texture | null>;
        mapUvTransform: THREE_2.IUniform<THREE_2.Matrix3>;
        normalMap: THREE_2.IUniform<THREE_2.Texture | null>;
        normalMapUvTransform: THREE_2.IUniform<THREE_2.Matrix3>;
        normalScale: THREE_2.IUniform<THREE_2.Vector2>;
        emissive: THREE_2.IUniform<THREE_2.Color>;
        emissiveIntensity: THREE_2.IUniform<number>;
        emissiveMap: THREE_2.IUniform<THREE_2.Texture | null>;
        emissiveMapUvTransform: THREE_2.IUniform<THREE_2.Matrix3>;
        shadeColorFactor: THREE_2.IUniform<THREE_2.Color>;
        shadeMultiplyTexture: THREE_2.IUniform<THREE_2.Texture | null>;
        shadeMultiplyTextureUvTransform: THREE_2.IUniform<THREE_2.Matrix3>;
        shadingShiftFactor: THREE_2.IUniform<number>;
        shadingShiftTexture: THREE_2.IUniform<THREE_2.Texture | null>;
        shadingShiftTextureUvTransform: THREE_2.IUniform<THREE_2.Matrix3>;
        shadingShiftTextureScale: THREE_2.IUniform<number>;
        shadingToonyFactor: THREE_2.IUniform<number>;
        giEqualizationFactor: THREE_2.IUniform<number>;
        matcapFactor: THREE_2.IUniform<THREE_2.Color>;
        matcapTexture: THREE_2.IUniform<THREE_2.Texture | null>;
        matcapTextureUvTransform: THREE_2.IUniform<THREE_2.Matrix3>;
        parametricRimColorFactor: THREE_2.IUniform<THREE_2.Color>;
        rimMultiplyTexture: THREE_2.IUniform<THREE_2.Texture | null>;
        rimMultiplyTextureUvTransform: THREE_2.IUniform<THREE_2.Matrix3>;
        rimLightingMixFactor: THREE_2.IUniform<number>;
        parametricRimFresnelPowerFactor: THREE_2.IUniform<number>;
        parametricRimLiftFactor: THREE_2.IUniform<number>;
        outlineWidthMultiplyTexture: THREE_2.IUniform<THREE_2.Texture | null>;
        outlineWidthMultiplyTextureUvTransform: THREE_2.IUniform<THREE_2.Matrix3>;
        outlineWidthFactor: THREE_2.IUniform<number>;
        outlineColorFactor: THREE_2.IUniform<THREE_2.Color>;
        outlineLightingMixFactor: THREE_2.IUniform<number>;
        uvAnimationMaskTexture: THREE_2.IUniform<THREE_2.Texture | null>;
        uvAnimationMaskTextureUvTransform: THREE_2.IUniform<THREE_2.Matrix3>;
        uvAnimationScrollXOffset: THREE_2.IUniform<number>;
        uvAnimationScrollYOffset: THREE_2.IUniform<number>;
        uvAnimationRotationPhase: THREE_2.IUniform<number>;
    };
    update(delta: number): void;
    // (undocumented)
    get uvAnimationMaskTexture(): THREE_2.Texture | null;
    set uvAnimationMaskTexture(value: THREE_2.Texture | null);
    // (undocumented)
    get uvAnimationRotationPhase(): number;
    set uvAnimationRotationPhase(value: number);
    // (undocumented)
    uvAnimationRotationSpeedFactor: number;
    // (undocumented)
    get uvAnimationScrollXOffset(): number;
    set uvAnimationScrollXOffset(value: number);
    // (undocumented)
    uvAnimationScrollXSpeedFactor: number;
    // (undocumented)
    get uvAnimationScrollYOffset(): number;
    set uvAnimationScrollYOffset(value: number);
    // (undocumented)
    uvAnimationScrollYSpeedFactor: number;
    get v0CompatShade(): boolean;
    set v0CompatShade(v: boolean);
}

// @public
export const MToonMaterialDebugMode: {
    readonly None: "none";
    readonly Normal: "normal";
    readonly LitShadeRate: "litShadeRate";
    readonly UV: "uv";
};

// @public (undocumented)
export type MToonMaterialDebugMode = typeof MToonMaterialDebugMode[keyof typeof MToonMaterialDebugMode];

// @public (undocumented)
export class MToonMaterialLoaderPlugin implements GLTFLoaderPlugin {
    constructor(parser: GLTFParser, options?: MToonMaterialLoaderPluginOptions);
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    // (undocumented)
    beforeRoot(): Promise<void>;
    debugMode: MToonMaterialDebugMode;
    // (undocumented)
    extendMaterialParams(materialIndex: number, materialParams: MToonMaterialParameters): Promise<any> | null;
    // (undocumented)
    static EXTENSION_NAME: string;
    // (undocumented)
    getMaterialType(materialIndex: number): typeof THREE_2.Material | null;
    // (undocumented)
    loadMesh(meshIndex: number): Promise<THREE_2.Group | THREE_2.Mesh | THREE_2.SkinnedMesh>;
    // (undocumented)
    get name(): string;
    // (undocumented)
    readonly parser: GLTFParser;
    renderOrderOffset: number;
    v0CompatShade: boolean;
}

// @public (undocumented)
export interface MToonMaterialLoaderPluginOptions {
    debugMode?: MToonMaterialDebugMode;
    renderOrderOffset?: number;
    v0CompatShade?: boolean;
}

// @public (undocumented)
export const MToonMaterialOutlineWidthMode: {
    readonly None: "none";
    readonly WorldCoordinates: "worldCoordinates";
    readonly ScreenCoordinates: "screenCoordinates";
};

// @public (undocumented)
export type MToonMaterialOutlineWidthMode = typeof MToonMaterialOutlineWidthMode[keyof typeof MToonMaterialOutlineWidthMode];

// @public (undocumented)
export interface MToonMaterialParameters extends THREE.ShaderMaterialParameters {
    // (undocumented)
    color?: THREE.Color;
    debugMode?: MToonMaterialDebugMode;
    // (undocumented)
    emissive?: THREE.Color;
    // (undocumented)
    emissiveIntensity?: number;
    // (undocumented)
    emissiveMap?: THREE.Texture;
    fog?: boolean;
    // (undocumented)
    giEqualizationFactor?: number;
    ignoreVertexColor?: boolean;
    isOutline?: boolean;
    // (undocumented)
    map?: THREE.Texture;
    // (undocumented)
    matcapFactor?: THREE.Color;
    // (undocumented)
    matcapTexture?: THREE.Texture;
    // (undocumented)
    normalMap?: THREE.Texture;
    // (undocumented)
    normalScale?: THREE.Vector2;
    // (undocumented)
    outlineColorFactor?: THREE.Color;
    // (undocumented)
    outlineLightingMixFactor?: number;
    // (undocumented)
    outlineWidthFactor?: number;
    // (undocumented)
    outlineWidthMode?: MToonMaterialOutlineWidthMode;
    // (undocumented)
    outlineWidthMultiplyTexture?: THREE.Texture;
    // (undocumented)
    parametricRimColorFactor?: THREE.Color;
    // (undocumented)
    parametricRimFresnelPowerFactor?: number;
    // (undocumented)
    parametricRimLiftFactor?: number;
    // (undocumented)
    rimLightingMixFactor?: number;
    // (undocumented)
    rimMultiplyTexture?: THREE.Texture;
    // (undocumented)
    shadeColorFactor?: THREE.Color;
    // (undocumented)
    shadeMultiplyTexture?: THREE.Texture;
    // (undocumented)
    shadingShiftFactor?: number;
    // (undocumented)
    shadingShiftTexture?: THREE.Texture;
    // (undocumented)
    shadingShiftTextureScale?: number;
    // (undocumented)
    shadingToonyFactor?: number;
    transparentWithZWrite?: boolean;
    // (undocumented)
    uvAnimationMaskTexture?: THREE.Texture;
    // (undocumented)
    uvAnimationRotationSpeedFactor?: number;
    // (undocumented)
    uvAnimationScrollXSpeedFactor?: number;
    // (undocumented)
    uvAnimationScrollYSpeedFactor?: number;
    v0CompatShade?: boolean;
}

// @public
export class VRM extends VRMCore {
    constructor(params: VRMParameters);
    readonly materials?: THREE_2.Material[];
    readonly nodeConstraintManager?: VRMNodeConstraintManager;
    readonly springBoneManager?: VRMSpringBoneManager;
    update(delta: number): void;
}

// @public
export interface VRM0Meta {
    allowedUserName?: 'Everyone' | 'ExplicitlyLicensedPerson' | 'OnlyAuthor';
    author?: string;
    commercialUssageName?: 'Allow' | 'Disallow';
    contactInformation?: string;
    licenseName?: 'CC0' | 'CC_BY' | 'CC_BY_NC' | 'CC_BY_NC_ND' | 'CC_BY_NC_SA' | 'CC_BY_ND' | 'CC_BY_SA' | 'Other' | 'Redistribution_Prohibited';
    metaVersion: '0';
    otherLicenseUrl?: string;
    otherPermissionUrl?: string;
    reference?: string;
    sexualUssageName?: 'Allow' | 'Disallow';
    texture?: THREE_2.Texture;
    title?: string;
    version?: string;
    violentUssageName?: 'Allow' | 'Disallow';
}

// @public
export interface VRM1Meta {
    allowAntisocialOrHateUsage?: boolean;
    allowExcessivelySexualUsage?: boolean;
    allowExcessivelyViolentUsage?: boolean;
    allowPoliticalOrReligiousUsage?: boolean;
    allowRedistribution?: boolean;
    authors: string[];
    avatarPermission?: 'onlyAuthor' | 'onlySeparatelyLicensedPerson' | 'everyone';
    commercialUsage?: 'personalNonProfit' | 'personalProfit' | 'corporation';
    contactInformation?: string;
    copyrightInformation?: string;
    creditNotation?: 'required' | 'unnecessary';
    licenseUrl: string;
    metaVersion: '1';
    modification?: 'prohibited' | 'allowModification' | 'allowModificationRedistribution';
    name: string;
    otherLicenseUrl?: string;
    references?: string[];
    thirdPartyLicenses?: string;
    thumbnailImage?: HTMLImageElement;
    version?: string;
}

// @public
export class VRMAimConstraint extends VRMNodeConstraint {
    constructor(destination: THREE_2.Object3D, source: THREE_2.Object3D);
    get aimAxis(): 'PositiveX' | 'NegativeX' | 'PositiveY' | 'NegativeY' | 'PositiveZ' | 'NegativeZ';
    set aimAxis(aimAxis: 'PositiveX' | 'NegativeX' | 'PositiveY' | 'NegativeY' | 'PositiveZ' | 'NegativeZ');
    // (undocumented)
    get dependencies(): Set<THREE_2.Object3D<THREE_2.Event>>;
    // (undocumented)
    setInitState(): void;
    // (undocumented)
    update(): void;
}

// @public
export class VRMCore {
    constructor(params: VRMCoreParameters);
    readonly expressionManager?: VRMExpressionManager;
    readonly firstPerson?: VRMFirstPerson;
    readonly humanoid: VRMHumanoid;
    readonly lookAt?: VRMLookAt;
    readonly meta: VRMMeta;
    readonly scene: THREE_2.Group;
    update(delta: number): void;
}

// @public (undocumented)
export class VRMCoreLoaderPlugin implements GLTFLoaderPlugin {
    constructor(parser: GLTFParser, options?: VRMCoreLoaderPluginOptions);
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    // (undocumented)
    readonly expressionPlugin: VRMExpressionLoaderPlugin;
    // (undocumented)
    readonly firstPersonPlugin: VRMFirstPersonLoaderPlugin;
    // (undocumented)
    readonly humanoidPlugin: VRMHumanoidLoaderPlugin;
    // (undocumented)
    readonly lookAtPlugin: VRMLookAtLoaderPlugin;
    // (undocumented)
    readonly metaPlugin: VRMMetaLoaderPlugin;
    // (undocumented)
    get name(): string;
    // (undocumented)
    readonly parser: GLTFParser;
}

// @public (undocumented)
export interface VRMCoreLoaderPluginOptions {
    // (undocumented)
    autoUpdateHumanBones?: boolean;
    // (undocumented)
    expressionPlugin?: VRMExpressionLoaderPlugin;
    // (undocumented)
    firstPersonPlugin?: VRMFirstPersonLoaderPlugin;
    helperRoot?: THREE.Object3D;
    // (undocumented)
    humanoidPlugin?: VRMHumanoidLoaderPlugin;
    // (undocumented)
    lookAtPlugin?: VRMLookAtLoaderPlugin;
    // (undocumented)
    metaPlugin?: VRMMetaLoaderPlugin;
}

// @public
export interface VRMCoreParameters {
    // (undocumented)
    expressionManager?: VRMExpressionManager;
    // (undocumented)
    firstPerson?: VRMFirstPerson;
    // (undocumented)
    humanoid: VRMHumanoid;
    // (undocumented)
    lookAt?: VRMLookAt;
    // (undocumented)
    meta: VRMMeta;
    // (undocumented)
    scene: THREE.Group;
}

// @public (undocumented)
export class VRMExpression extends THREE_2.Object3D {
    constructor(expressionName: string);
    // (undocumented)
    addBind(bind: VRMExpressionBind): void;
    applyWeight(options?: {
        multiplier?: number;
    }): void;
    clearAppliedWeight(): void;
    expressionName: string;
    isBinary: boolean;
    overrideBlink: VRMExpressionOverrideType;
    get overrideBlinkAmount(): number;
    overrideLookAt: VRMExpressionOverrideType;
    get overrideLookAtAmount(): number;
    overrideMouth: VRMExpressionOverrideType;
    get overrideMouthAmount(): number;
    // (undocumented)
    readonly type: string | 'VRMExpression';
    weight: number;
}

// @public (undocumented)
export interface VRMExpressionBind {
    applyWeight(weight: number): void;
    clearAppliedWeight(): void;
}

// @public
export class VRMExpressionLoaderPlugin implements GLTFLoaderPlugin {
    constructor(parser: GLTFParser);
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    // (undocumented)
    get name(): string;
    // (undocumented)
    readonly parser: GLTFParser;
    // Warning: (ae-forgotten-export) The symbol "V0VRM" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static readonly v0v1PresetNameMap: {
        [v0Name in V0VRM.BlendShapePresetName]?: VRMExpressionPresetName;
    };
}

// @public (undocumented)
export class VRMExpressionManager {
    constructor();
    blinkExpressionNames: string[];
    clone(): VRMExpressionManager;
    copy(source: VRMExpressionManager): this;
    get customExpressionMap(): {
        [name: string]: VRMExpression;
    };
    // (undocumented)
    get expressionMap(): {
        [name: string]: VRMExpression;
    };
    // (undocumented)
    get expressions(): VRMExpression[];
    getExpression(name: VRMExpressionPresetName | string): VRMExpression | null;
    getExpressionTrackName(name: VRMExpressionPresetName | string): string | null;
    getValue(name: VRMExpressionPresetName | string): number | null;
    lookAtExpressionNames: string[];
    mouthExpressionNames: string[];
    get presetExpressionMap(): {
        [name in VRMExpressionPresetName]?: VRMExpression;
    };
    registerExpression(expression: VRMExpression): void;
    setValue(name: VRMExpressionPresetName | string, weight: number): void;
    unregisterExpression(expression: VRMExpression): void;
    update(): void;
}

// @public
export class VRMExpressionMaterialColorBind implements VRMExpressionBind {
    constructor({ material, type, targetValue, }: {
        material: THREE_2.Material;
        type: VRMExpressionMaterialColorType;
        targetValue: THREE_2.Color;
    });
    // (undocumented)
    applyWeight(weight: number): void;
    // (undocumented)
    clearAppliedWeight(): void;
    readonly material: THREE_2.Material;
    readonly targetValue: THREE_2.Color;
    readonly type: VRMExpressionMaterialColorType;
}

// @public (undocumented)
export const VRMExpressionMaterialColorType: {
    readonly Color: "color";
    readonly EmissionColor: "emissionColor";
    readonly ShadeColor: "shadeColor";
    readonly MatcapColor: "matcapColor";
    readonly RimColor: "rimColor";
    readonly OutlineColor: "outlineColor";
};

// @public (undocumented)
export type VRMExpressionMaterialColorType = typeof VRMExpressionMaterialColorType[keyof typeof VRMExpressionMaterialColorType];

// @public
export class VRMExpressionMorphTargetBind implements VRMExpressionBind {
    constructor({ primitives, index, weight, }: {
        primitives: THREE_2.Mesh[];
        index: number;
        weight: number;
    });
    // (undocumented)
    applyWeight(weight: number): void;
    // (undocumented)
    clearAppliedWeight(): void;
    readonly index: number;
    readonly primitives: THREE_2.Mesh[];
    readonly weight: number;
}

// @public (undocumented)
export const VRMExpressionOverrideType: {
    readonly None: "none";
    readonly Block: "block";
    readonly Blend: "blend";
};

// @public (undocumented)
export type VRMExpressionOverrideType = typeof VRMExpressionOverrideType[keyof typeof VRMExpressionOverrideType];

// @public (undocumented)
export const VRMExpressionPresetName: {
    readonly Aa: "aa";
    readonly Ih: "ih";
    readonly Ou: "ou";
    readonly Ee: "ee";
    readonly Oh: "oh";
    readonly Blink: "blink";
    readonly Happy: "happy";
    readonly Angry: "angry";
    readonly Sad: "sad";
    readonly Relaxed: "relaxed";
    readonly LookUp: "lookUp";
    readonly Surprised: "surprised";
    readonly LookDown: "lookDown";
    readonly LookLeft: "lookLeft";
    readonly LookRight: "lookRight";
    readonly BlinkLeft: "blinkLeft";
    readonly BlinkRight: "blinkRight";
    readonly Neutral: "neutral";
};

// @public (undocumented)
export type VRMExpressionPresetName = typeof VRMExpressionPresetName[keyof typeof VRMExpressionPresetName];

// @public
export class VRMExpressionTextureTransformBind implements VRMExpressionBind {
    constructor({ material, scale, offset, }: {
        material: THREE_2.Material;
        scale: THREE_2.Vector2;
        offset: THREE_2.Vector2;
    });
    // (undocumented)
    applyWeight(weight: number): void;
    // (undocumented)
    clearAppliedWeight(): void;
    readonly material: THREE_2.Material;
    readonly offset: THREE_2.Vector2;
    readonly scale: THREE_2.Vector2;
}

// @public (undocumented)
export class VRMFirstPerson {
    constructor(humanoid: VRMHumanoid, meshAnnotations: VRMFirstPersonMeshAnnotation[]);
    clone(): VRMFirstPerson;
    copy(source: VRMFirstPerson): this;
    static readonly DEFAULT_FIRSTPERSON_ONLY_LAYER = 9;
    static readonly DEFAULT_THIRDPERSON_ONLY_LAYER = 10;
    get firstPersonOnlyLayer(): number;
    readonly humanoid: VRMHumanoid;
    // (undocumented)
    meshAnnotations: VRMFirstPersonMeshAnnotation[];
    setup({ firstPersonOnlyLayer, thirdPersonOnlyLayer, }?: {
        firstPersonOnlyLayer?: number | undefined;
        thirdPersonOnlyLayer?: number | undefined;
    }): void;
    get thirdPersonOnlyLayer(): number;
}

// @public
export class VRMFirstPersonLoaderPlugin implements GLTFLoaderPlugin {
    constructor(parser: GLTFParser);
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    // (undocumented)
    get name(): string;
    // (undocumented)
    readonly parser: GLTFParser;
}

// @public (undocumented)
export interface VRMFirstPersonMeshAnnotation {
    // (undocumented)
    meshes: THREE.Mesh[];
    // (undocumented)
    type: VRMFirstPersonMeshAnnotationType;
}

// @public (undocumented)
export const VRMFirstPersonMeshAnnotationType: {
    readonly Auto: "auto";
    readonly Both: "both";
    readonly ThirdPersonOnly: "thirdPersonOnly";
    readonly FirstPersonOnly: "firstPersonOnly";
};

// @public (undocumented)
export type VRMFirstPersonMeshAnnotationType = typeof VRMFirstPersonMeshAnnotationType[keyof typeof VRMFirstPersonMeshAnnotationType];

// @public
export interface VRMHumanBone {
    node: THREE_2.Object3D;
}

// @public
export const VRMHumanBoneList: VRMHumanBoneName[];

// @public
export const VRMHumanBoneName: {
    readonly Hips: "hips";
    readonly Spine: "spine";
    readonly Chest: "chest";
    readonly UpperChest: "upperChest";
    readonly Neck: "neck";
    readonly Head: "head";
    readonly LeftEye: "leftEye";
    readonly RightEye: "rightEye";
    readonly Jaw: "jaw";
    readonly LeftUpperLeg: "leftUpperLeg";
    readonly LeftLowerLeg: "leftLowerLeg";
    readonly LeftFoot: "leftFoot";
    readonly LeftToes: "leftToes";
    readonly RightUpperLeg: "rightUpperLeg";
    readonly RightLowerLeg: "rightLowerLeg";
    readonly RightFoot: "rightFoot";
    readonly RightToes: "rightToes";
    readonly LeftShoulder: "leftShoulder";
    readonly LeftUpperArm: "leftUpperArm";
    readonly LeftLowerArm: "leftLowerArm";
    readonly LeftHand: "leftHand";
    readonly RightShoulder: "rightShoulder";
    readonly RightUpperArm: "rightUpperArm";
    readonly RightLowerArm: "rightLowerArm";
    readonly RightHand: "rightHand";
    readonly LeftThumbMetacarpal: "leftThumbMetacarpal";
    readonly LeftThumbProximal: "leftThumbProximal";
    readonly LeftThumbDistal: "leftThumbDistal";
    readonly LeftIndexProximal: "leftIndexProximal";
    readonly LeftIndexIntermediate: "leftIndexIntermediate";
    readonly LeftIndexDistal: "leftIndexDistal";
    readonly LeftMiddleProximal: "leftMiddleProximal";
    readonly LeftMiddleIntermediate: "leftMiddleIntermediate";
    readonly LeftMiddleDistal: "leftMiddleDistal";
    readonly LeftRingProximal: "leftRingProximal";
    readonly LeftRingIntermediate: "leftRingIntermediate";
    readonly LeftRingDistal: "leftRingDistal";
    readonly LeftLittleProximal: "leftLittleProximal";
    readonly LeftLittleIntermediate: "leftLittleIntermediate";
    readonly LeftLittleDistal: "leftLittleDistal";
    readonly RightThumbMetacarpal: "rightThumbMetacarpal";
    readonly RightThumbProximal: "rightThumbProximal";
    readonly RightThumbDistal: "rightThumbDistal";
    readonly RightIndexProximal: "rightIndexProximal";
    readonly RightIndexIntermediate: "rightIndexIntermediate";
    readonly RightIndexDistal: "rightIndexDistal";
    readonly RightMiddleProximal: "rightMiddleProximal";
    readonly RightMiddleIntermediate: "rightMiddleIntermediate";
    readonly RightMiddleDistal: "rightMiddleDistal";
    readonly RightRingProximal: "rightRingProximal";
    readonly RightRingIntermediate: "rightRingIntermediate";
    readonly RightRingDistal: "rightRingDistal";
    readonly RightLittleProximal: "rightLittleProximal";
    readonly RightLittleIntermediate: "rightLittleIntermediate";
    readonly RightLittleDistal: "rightLittleDistal";
};

// @public (undocumented)
export type VRMHumanBoneName = typeof VRMHumanBoneName[keyof typeof VRMHumanBoneName];

// @public
export const VRMHumanBoneParentMap: {
    [bone in VRMHumanBoneName]: VRMHumanBoneName | null;
};

// @public
export type VRMHumanBones = {
    [name in VRMHumanBoneName]?: VRMHumanBone;
} & {
    [name in VRMRequiredHumanBoneName]: VRMHumanBone;
};

// @public
export class VRMHumanoid {
    constructor(humanBones: VRMHumanBones, options?: {
        autoUpdateHumanBones?: boolean;
    });
    autoUpdateHumanBones: boolean;
    clone(): VRMHumanoid;
    copy(source: VRMHumanoid): this;
    // @deprecated (undocumented)
    getAbsolutePose(): VRMPose;
    // @deprecated (undocumented)
    getBone(name: VRMHumanBoneName): VRMHumanBone | undefined;
    // @deprecated (undocumented)
    getBoneNode(name: VRMHumanBoneName): THREE_2.Object3D | null;
    getNormalizedAbsolutePose(): VRMPose;
    getNormalizedBone(name: VRMHumanBoneName): VRMHumanBone | undefined;
    getNormalizedBoneNode(name: VRMHumanBoneName): THREE_2.Object3D | null;
    getNormalizedPose(): VRMPose;
    // @deprecated (undocumented)
    getPose(): VRMPose;
    getRawAbsolutePose(): VRMPose;
    getRawBone(name: VRMHumanBoneName): VRMHumanBone | undefined;
    getRawBoneNode(name: VRMHumanBoneName): THREE_2.Object3D | null;
    getRawPose(): VRMPose;
    get humanBones(): VRMHumanBones;
    get normalizedHumanBones(): VRMHumanBones;
    get normalizedHumanBonesRoot(): THREE_2.Object3D;
    get normalizedRestPose(): VRMPose;
    get rawHumanBones(): VRMHumanBones;
    get rawRestPose(): VRMPose;
    resetNormalizedPose(): void;
    // @deprecated (undocumented)
    resetPose(): void;
    resetRawPose(): void;
    // @deprecated (undocumented)
    get restPose(): VRMPose;
    setNormalizedPose(poseObject: VRMPose): void;
    // @deprecated (undocumented)
    setPose(poseObject: VRMPose): void;
    setRawPose(poseObject: VRMPose): void;
    update(): void;
}

// @public (undocumented)
export class VRMHumanoidHelper extends THREE_2.Group {
    constructor(humanoid: VRMHumanoid);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    updateMatrixWorld(force: boolean): void;
    // (undocumented)
    readonly vrmHumanoid: VRMHumanoid;
}

// @public
export class VRMHumanoidLoaderPlugin implements GLTFLoaderPlugin {
    constructor(parser: GLTFParser, options?: VRMHumanoidLoaderPluginOptions);
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    // (undocumented)
    autoUpdateHumanBones?: boolean;
    helperRoot?: THREE.Object3D;
    // (undocumented)
    get name(): string;
    // (undocumented)
    readonly parser: GLTFParser;
}

// @public (undocumented)
export interface VRMHumanoidLoaderPluginOptions {
    autoUpdateHumanBones?: boolean;
    helperRoot?: THREE.Object3D;
}

// @public (undocumented)
export class VRMLoaderPlugin implements GLTFLoaderPlugin {
    constructor(parser: GLTFParser, options?: VRMLoaderPluginOptions);
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    // (undocumented)
    beforeRoot(): Promise<void>;
    // (undocumented)
    readonly expressionPlugin: VRMExpressionLoaderPlugin;
    // (undocumented)
    extendMaterialParams(materialIndex: number, materialParams: {
        [key: string]: any;
    }): Promise<any>;
    // (undocumented)
    readonly firstPersonPlugin: VRMFirstPersonLoaderPlugin;
    // (undocumented)
    getMaterialType(materialIndex: number): typeof THREE_2.Material | null;
    // (undocumented)
    readonly humanoidPlugin: VRMHumanoidLoaderPlugin;
    // (undocumented)
    loadMesh(meshIndex: number): Promise<THREE_2.Group | THREE_2.Mesh | THREE_2.SkinnedMesh>;
    // (undocumented)
    readonly lookAtPlugin: VRMLookAtLoaderPlugin;
    // Warning: (ae-forgotten-export) The symbol "VRMMaterialsHDREmissiveMultiplierLoaderPlugin" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly materialsHDREmissiveMultiplierPlugin: VRMMaterialsHDREmissiveMultiplierLoaderPlugin;
    // Warning: (ae-forgotten-export) The symbol "VRMMaterialsV0CompatPlugin" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly materialsV0CompatPlugin: VRMMaterialsV0CompatPlugin;
    // (undocumented)
    readonly metaPlugin: VRMMetaLoaderPlugin;
    // (undocumented)
    readonly mtoonMaterialPlugin: MToonMaterialLoaderPlugin;
    // (undocumented)
    get name(): string;
    // (undocumented)
    readonly nodeConstraintPlugin: VRMNodeConstraintLoaderPlugin;
    // (undocumented)
    readonly parser: GLTFParser;
    // (undocumented)
    readonly springBonePlugin: VRMSpringBoneLoaderPlugin;
}

// @public (undocumented)
export interface VRMLoaderPluginOptions {
    autoUpdateHumanBones?: boolean;
    // (undocumented)
    expressionPlugin?: VRMExpressionLoaderPlugin;
    // (undocumented)
    firstPersonPlugin?: VRMFirstPersonLoaderPlugin;
    helperRoot?: THREE_2.Object3D;
    // (undocumented)
    humanoidPlugin?: VRMHumanoidLoaderPlugin;
    // (undocumented)
    lookAtPlugin?: VRMLookAtLoaderPlugin;
    // (undocumented)
    materialsHDREmissiveMultiplierPlugin?: VRMMaterialsHDREmissiveMultiplierLoaderPlugin;
    // (undocumented)
    materialsV0CompatPlugin?: VRMMaterialsV0CompatPlugin;
    // (undocumented)
    metaPlugin?: VRMMetaLoaderPlugin;
    // (undocumented)
    mtoonMaterialPlugin?: MToonMaterialLoaderPlugin;
    // (undocumented)
    nodeConstraintPlugin?: VRMNodeConstraintLoaderPlugin;
    // (undocumented)
    springBonePlugin?: VRMSpringBoneLoaderPlugin;
}

// @public
export class VRMLookAt {
    constructor(humanoid: VRMHumanoid, applier: VRMLookAtApplier);
    applier: VRMLookAtApplier;
    autoUpdate: boolean;
    clone(): VRMLookAt;
    copy(source: VRMLookAt): this;
    // @deprecated (undocumented)
    get euler(): THREE_2.Euler;
    // (undocumented)
    static readonly EULER_ORDER = "YXZ";
    faceFront: THREE_2.Vector3;
    getEuler(target: THREE_2.Euler): THREE_2.Euler;
    getFaceFrontQuaternion(target: THREE_2.Quaternion): THREE_2.Quaternion;
    getLookAtWorldDirection(target: THREE_2.Vector3): THREE_2.Vector3;
    getLookAtWorldPosition(target: THREE_2.Vector3): THREE_2.Vector3;
    getLookAtWorldQuaternion(target: THREE_2.Quaternion): THREE_2.Quaternion;
    readonly humanoid: VRMHumanoid;
    lookAt(position: THREE_2.Vector3): void;
    protected _needsUpdate: boolean;
    offsetFromHeadBone: THREE_2.Vector3;
    get pitch(): number;
    set pitch(value: number);
    protected _pitch: number;
    reset(): void;
    target?: THREE_2.Object3D | null;
    update(delta: number): void;
    get yaw(): number;
    set yaw(value: number);
    protected _yaw: number;
}

// @public
export interface VRMLookAtApplier {
    applyYawPitch: (yaw: number, pitch: number) => void;
    // @deprecated (undocumented)
    lookAt: (euler: THREE_2.Euler) => void;
}

// @public
export class VRMLookAtBoneApplier implements VRMLookAtApplier {
    constructor(humanoid: VRMHumanoid, rangeMapHorizontalInner: VRMLookAtRangeMap, rangeMapHorizontalOuter: VRMLookAtRangeMap, rangeMapVerticalDown: VRMLookAtRangeMap, rangeMapVerticalUp: VRMLookAtRangeMap);
    applyYawPitch(yaw: number, pitch: number): void;
    faceFront: THREE_2.Vector3;
    readonly humanoid: VRMHumanoid;
    // @deprecated (undocumented)
    lookAt(euler: THREE_2.Euler): void;
    rangeMapHorizontalInner: VRMLookAtRangeMap;
    rangeMapHorizontalOuter: VRMLookAtRangeMap;
    rangeMapVerticalDown: VRMLookAtRangeMap;
    rangeMapVerticalUp: VRMLookAtRangeMap;
    static readonly type = "bone";
}

// @public
export class VRMLookAtExpressionApplier implements VRMLookAtApplier {
    constructor(expressions: VRMExpressionManager, rangeMapHorizontalInner: VRMLookAtRangeMap, rangeMapHorizontalOuter: VRMLookAtRangeMap, rangeMapVerticalDown: VRMLookAtRangeMap, rangeMapVerticalUp: VRMLookAtRangeMap);
    applyYawPitch(yaw: number, pitch: number): void;
    readonly expressions: VRMExpressionManager;
    // @deprecated (undocumented)
    lookAt(euler: THREE_2.Euler): void;
    rangeMapHorizontalInner: VRMLookAtRangeMap;
    rangeMapHorizontalOuter: VRMLookAtRangeMap;
    rangeMapVerticalDown: VRMLookAtRangeMap;
    rangeMapVerticalUp: VRMLookAtRangeMap;
    static readonly type = "expression";
}

// @public (undocumented)
export class VRMLookAtHelper extends THREE_2.Group {
    constructor(lookAt: VRMLookAt);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    updateMatrixWorld(force: boolean): void;
    // (undocumented)
    readonly vrmLookAt: VRMLookAt;
}

// @public
export class VRMLookAtLoaderPlugin implements GLTFLoaderPlugin {
    // Warning: (ae-forgotten-export) The symbol "VRMLookAtLoaderPluginOptions" needs to be exported by the entry point index.d.ts
    constructor(parser: GLTFParser, options?: VRMLookAtLoaderPluginOptions);
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    helperRoot?: THREE.Object3D;
    // (undocumented)
    get name(): string;
    // (undocumented)
    readonly parser: GLTFParser;
}

// @public (undocumented)
export class VRMLookAtRangeMap {
    constructor(inputMaxValue: number, outputScale: number);
    inputMaxValue: number;
    map(src: number): number;
    outputScale: number;
}

// @public
export const VRMLookAtTypeName: {
    Bone: string;
    Expression: string;
};

// @public (undocumented)
export type VRMLookAtTypeName = typeof VRMLookAtTypeName[keyof typeof VRMLookAtTypeName];

// @public
export type VRMMeta = VRM0Meta | VRM1Meta;

// @public
export interface VRMMetaImporterOptions {
    acceptLicenseUrls?: string[];
    acceptV0Meta?: boolean;
    needThumbnailImage?: boolean;
}

// @public
export class VRMMetaLoaderPlugin implements GLTFLoaderPlugin {
    constructor(parser: GLTFParser, options?: VRMMetaImporterOptions);
    acceptLicenseUrls: string[];
    acceptV0Meta: boolean;
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    // (undocumented)
    get name(): string;
    needThumbnailImage: boolean;
    // (undocumented)
    readonly parser: GLTFParser;
}

// @public
export abstract class VRMNodeConstraint {
    constructor(destination: THREE_2.Object3D, source: THREE_2.Object3D);
    // (undocumented)
    abstract get dependencies(): Set<THREE_2.Object3D>;
    destination: THREE_2.Object3D;
    abstract setInitState(): void;
    source: THREE_2.Object3D;
    abstract update(): void;
    weight: number;
}

// @public (undocumented)
export class VRMNodeConstraintHelper extends THREE_2.Group {
    constructor(constraint: VRMNodeConstraint);
    // (undocumented)
    readonly constraint: VRMNodeConstraint;
    // (undocumented)
    updateMatrixWorld(force?: boolean): void;
}

// @public (undocumented)
export class VRMNodeConstraintLoaderPlugin implements GLTFLoaderPlugin {
    // Warning: (ae-forgotten-export) The symbol "VRMNodeConstraintLoaderPluginOptions" needs to be exported by the entry point index.d.ts
    constructor(parser: GLTFParser, options?: VRMNodeConstraintLoaderPluginOptions);
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    // (undocumented)
    static readonly EXTENSION_NAME = "VRMC_node_constraint";
    helperRoot?: THREE_2.Object3D;
    protected _import(gltf: GLTF): Promise<VRMNodeConstraintManager | null>;
    // (undocumented)
    protected _importAimConstraint(destination: THREE_2.Object3D, nodes: THREE_2.Object3D[], aimConstraintDef: ConstraintSchema.AimConstraint): VRMAimConstraint;
    // Warning: (ae-forgotten-export) The symbol "ConstraintSchema" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected _importRollConstraint(destination: THREE_2.Object3D, nodes: THREE_2.Object3D[], rollConstraintDef: ConstraintSchema.RollConstraint): VRMRollConstraint;
    // (undocumented)
    protected _importRotationConstraint(destination: THREE_2.Object3D, nodes: THREE_2.Object3D[], rotationConstraintDef: ConstraintSchema.RotationConstraint): VRMRotationConstraint;
    // (undocumented)
    get name(): string;
    // (undocumented)
    readonly parser: GLTFParser;
}

// @public (undocumented)
export class VRMNodeConstraintManager {
    // (undocumented)
    addConstraint(constraint: VRMNodeConstraint): void;
    // (undocumented)
    get constraints(): Set<VRMNodeConstraint>;
    // (undocumented)
    deleteConstraint(constraint: VRMNodeConstraint): void;
    // (undocumented)
    setInitState(): void;
    // (undocumented)
    update(): void;
}

// @public
export interface VRMParameters extends VRMCoreParameters {
    // (undocumented)
    materials?: THREE.Material[];
    // (undocumented)
    nodeConstraintManager?: VRMNodeConstraintManager;
    // (undocumented)
    springBoneManager?: VRMSpringBoneManager;
}

// @public
export type VRMPose = {
    [boneName in VRMHumanBoneName]?: VRMPoseTransform;
};

// @public
export interface VRMPoseTransform {
    position?: [number, number, number];
    rotation?: [number, number, number, number];
}

// @public (undocumented)
export const VRMRequiredHumanBoneName: {
    readonly Hips: "hips";
    readonly Spine: "spine";
    readonly Head: "head";
    readonly LeftUpperLeg: "leftUpperLeg";
    readonly LeftLowerLeg: "leftLowerLeg";
    readonly LeftFoot: "leftFoot";
    readonly RightUpperLeg: "rightUpperLeg";
    readonly RightLowerLeg: "rightLowerLeg";
    readonly RightFoot: "rightFoot";
    readonly LeftUpperArm: "leftUpperArm";
    readonly LeftLowerArm: "leftLowerArm";
    readonly LeftHand: "leftHand";
    readonly RightUpperArm: "rightUpperArm";
    readonly RightLowerArm: "rightLowerArm";
    readonly RightHand: "rightHand";
};

// @public (undocumented)
export type VRMRequiredHumanBoneName = typeof VRMRequiredHumanBoneName[keyof typeof VRMRequiredHumanBoneName];

// @public
export class VRMRollConstraint extends VRMNodeConstraint {
    constructor(destination: THREE_2.Object3D, source: THREE_2.Object3D);
    // (undocumented)
    get dependencies(): Set<THREE_2.Object3D<THREE_2.Event>>;
    get rollAxis(): 'X' | 'Y' | 'Z';
    set rollAxis(rollAxis: 'X' | 'Y' | 'Z');
    // (undocumented)
    setInitState(): void;
    // (undocumented)
    update(): void;
}

// @public
export class VRMRotationConstraint extends VRMNodeConstraint {
    constructor(destination: THREE_2.Object3D, source: THREE_2.Object3D);
    // (undocumented)
    get dependencies(): Set<THREE_2.Object3D<THREE_2.Event>>;
    // (undocumented)
    setInitState(): void;
    // (undocumented)
    update(): void;
}

// @public
export class VRMSpringBoneCollider extends THREE_2.Object3D {
    constructor(shape: VRMSpringBoneColliderShape);
    readonly shape: VRMSpringBoneColliderShape;
}

// @public
export interface VRMSpringBoneColliderGroup {
    colliders: VRMSpringBoneCollider[];
    name?: string;
}

// @public (undocumented)
export class VRMSpringBoneColliderHelper extends THREE_2.Group {
    constructor(collider: VRMSpringBoneCollider);
    // (undocumented)
    readonly collider: VRMSpringBoneCollider;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    updateMatrixWorld(force: boolean): void;
}

// @public
export abstract class VRMSpringBoneColliderShape {
    abstract calculateCollision(colliderMatrix: THREE.Matrix4, objectPosition: THREE.Vector3, objectRadius: number, target: THREE.Vector3): number;
    abstract get type(): string;
}

// @public (undocumented)
export class VRMSpringBoneColliderShapeCapsule extends VRMSpringBoneColliderShape {
    constructor(params?: {
        radius?: number;
        offset?: THREE_2.Vector3;
        tail?: THREE_2.Vector3;
    });
    // (undocumented)
    calculateCollision(colliderMatrix: THREE_2.Matrix4, objectPosition: THREE_2.Vector3, objectRadius: number, target: THREE_2.Vector3): number;
    offset: THREE_2.Vector3;
    radius: number;
    tail: THREE_2.Vector3;
    // (undocumented)
    get type(): 'capsule';
}

// @public (undocumented)
export class VRMSpringBoneColliderShapeSphere extends VRMSpringBoneColliderShape {
    constructor(params?: {
        radius?: number;
        offset?: THREE_2.Vector3;
    });
    // (undocumented)
    calculateCollision(colliderMatrix: THREE_2.Matrix4, objectPosition: THREE_2.Vector3, objectRadius: number, target: THREE_2.Vector3): number;
    offset: THREE_2.Vector3;
    radius: number;
    // (undocumented)
    get type(): 'sphere';
}

// @public
export class VRMSpringBoneJoint {
    constructor(bone: THREE_2.Object3D, child: THREE_2.Object3D | null, settings?: Partial<VRMSpringBoneJointSettings>, colliderGroups?: VRMSpringBoneColliderGroup[]);
    readonly bone: THREE_2.Object3D;
    // (undocumented)
    get center(): THREE_2.Object3D | null;
    set center(center: THREE_2.Object3D | null);
    readonly child: THREE_2.Object3D | null;
    colliderGroups: VRMSpringBoneColliderGroup[];
    // (undocumented)
    get initialLocalChildPosition(): THREE_2.Vector3;
    reset(): void;
    setInitState(): void;
    settings: VRMSpringBoneJointSettings;
    update(delta: number): void;
}

// @public (undocumented)
export class VRMSpringBoneJointHelper extends THREE_2.Group {
    constructor(springBone: VRMSpringBoneJoint);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    readonly springBone: VRMSpringBoneJoint;
    // (undocumented)
    updateMatrixWorld(force: boolean): void;
}

// @public (undocumented)
export interface VRMSpringBoneJointSettings {
    // (undocumented)
    dragForce: number;
    // (undocumented)
    gravityDir: THREE.Vector3;
    // (undocumented)
    gravityPower: number;
    hitRadius: number;
    // (undocumented)
    stiffness: number;
}

// @public (undocumented)
export class VRMSpringBoneLoaderPlugin implements GLTFLoaderPlugin {
    // Warning: (ae-forgotten-export) The symbol "VRMSpringBoneLoaderPluginOptions" needs to be exported by the entry point index.d.ts
    constructor(parser: GLTFParser, options?: VRMSpringBoneLoaderPluginOptions);
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    colliderHelperRoot?: THREE_2.Object3D;
    // (undocumented)
    static readonly EXTENSION_NAME = "VRMC_springBone";
    jointHelperRoot?: THREE_2.Object3D;
    // (undocumented)
    get name(): string;
    // (undocumented)
    readonly parser: GLTFParser;
}

// @public (undocumented)
export class VRMSpringBoneManager {
    // (undocumented)
    addJoint(joint: VRMSpringBoneJoint): void;
    // @deprecated (undocumented)
    addSpringBone(joint: VRMSpringBoneJoint): void;
    // (undocumented)
    get colliderGroups(): VRMSpringBoneColliderGroup[];
    // (undocumented)
    get colliders(): VRMSpringBoneCollider[];
    // (undocumented)
    deleteJoint(joint: VRMSpringBoneJoint): void;
    // @deprecated (undocumented)
    deleteSpringBone(joint: VRMSpringBoneJoint): void;
    // (undocumented)
    get joints(): Set<VRMSpringBoneJoint>;
    // (undocumented)
    reset(): void;
    // (undocumented)
    setInitState(): void;
    // @deprecated (undocumented)
    get springBones(): Set<VRMSpringBoneJoint>;
    // (undocumented)
    update(delta: number): void;
}

// @public (undocumented)
export class VRMUtils {
    // Warning: (ae-forgotten-export) The symbol "deepDispose" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static deepDispose: typeof deepDispose;
    // Warning: (ae-forgotten-export) The symbol "removeUnnecessaryJoints" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static removeUnnecessaryJoints: typeof removeUnnecessaryJoints;
    // Warning: (ae-forgotten-export) The symbol "removeUnnecessaryVertices" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static removeUnnecessaryVertices: typeof removeUnnecessaryVertices;
    // Warning: (ae-forgotten-export) The symbol "rotateVRM0" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static rotateVRM0: typeof rotateVRM0;
}

// (No @packageDocumentation comment for this package)

```
