## API Report File for "@pixiv/three-vrm-core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { GLTF } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { GLTFLoaderPlugin } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';
import * as THREE_2 from 'three';

// @public
export interface VRM0Meta {
    allowedUserName?: 'Everyone' | 'ExplicitlyLicensedPerson' | 'OnlyAuthor';
    author?: string;
    commercialUssageName?: 'Allow' | 'Disallow';
    contactInformation?: string;
    licenseName?: 'CC0' | 'CC_BY' | 'CC_BY_NC' | 'CC_BY_NC_ND' | 'CC_BY_NC_SA' | 'CC_BY_ND' | 'CC_BY_SA' | 'Other' | 'Redistribution_Prohibited';
    metaVersion: '0';
    otherLicenseUrl?: string;
    otherPermissionUrl?: string;
    reference?: string;
    sexualUssageName?: 'Allow' | 'Disallow';
    texture?: THREE_2.Texture;
    title?: string;
    version?: string;
    violentUssageName?: 'Allow' | 'Disallow';
}

// @public
export interface VRM1Meta {
    allowAntisocialOrHateUsage?: boolean;
    allowExcessivelySexualUsage?: boolean;
    allowExcessivelyViolentUsage?: boolean;
    allowPoliticalOrReligiousUsage?: boolean;
    allowRedistribution?: boolean;
    authors: string[];
    avatarPermission?: 'onlyAuthor' | 'onlySeparatelyLicensedPerson' | 'everyone';
    commercialUsage?: 'personalNonProfit' | 'personalProfit' | 'corporation';
    contactInformation?: string;
    copyrightInformation?: string;
    creditNotation?: 'required' | 'unnecessary';
    licenseUrl: string;
    metaVersion: '1';
    modification?: 'prohibited' | 'allowModification' | 'allowModificationRedistribution';
    name: string;
    otherLicenseUrl?: string;
    references?: string[];
    thirdPartyLicenses?: string;
    thumbnailImage?: HTMLImageElement;
    version?: string;
}

// @public
export class VRMCore {
    constructor(params: VRMCoreParameters);
    readonly expressionManager?: VRMExpressionManager;
    readonly firstPerson?: VRMFirstPerson;
    readonly humanoid: VRMHumanoid;
    readonly lookAt?: VRMLookAt;
    readonly meta: VRMMeta;
    readonly scene: THREE_2.Group;
    update(delta: number): void;
}

// @public (undocumented)
export class VRMCoreLoaderPlugin implements GLTFLoaderPlugin {
    constructor(parser: GLTFParser, options?: VRMCoreLoaderPluginOptions);
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    // (undocumented)
    readonly expressionPlugin: VRMExpressionLoaderPlugin;
    // (undocumented)
    readonly firstPersonPlugin: VRMFirstPersonLoaderPlugin;
    // (undocumented)
    readonly humanoidPlugin: VRMHumanoidLoaderPlugin;
    // (undocumented)
    readonly lookAtPlugin: VRMLookAtLoaderPlugin;
    // (undocumented)
    readonly metaPlugin: VRMMetaLoaderPlugin;
    // (undocumented)
    get name(): string;
    // (undocumented)
    readonly parser: GLTFParser;
}

// @public (undocumented)
export interface VRMCoreLoaderPluginOptions {
    // (undocumented)
    autoUpdateHumanBones?: boolean;
    // (undocumented)
    expressionPlugin?: VRMExpressionLoaderPlugin;
    // (undocumented)
    firstPersonPlugin?: VRMFirstPersonLoaderPlugin;
    helperRoot?: THREE.Object3D;
    // (undocumented)
    humanoidPlugin?: VRMHumanoidLoaderPlugin;
    // (undocumented)
    lookAtPlugin?: VRMLookAtLoaderPlugin;
    // (undocumented)
    metaPlugin?: VRMMetaLoaderPlugin;
}

// @public
export interface VRMCoreParameters {
    // (undocumented)
    expressionManager?: VRMExpressionManager;
    // (undocumented)
    firstPerson?: VRMFirstPerson;
    // (undocumented)
    humanoid: VRMHumanoid;
    // (undocumented)
    lookAt?: VRMLookAt;
    // (undocumented)
    meta: VRMMeta;
    // (undocumented)
    scene: THREE.Group;
}

// @public (undocumented)
export class VRMExpression extends THREE_2.Object3D {
    constructor(expressionName: string);
    // (undocumented)
    addBind(bind: VRMExpressionBind): void;
    applyWeight(options?: {
        multiplier?: number;
    }): void;
    clearAppliedWeight(): void;
    expressionName: string;
    isBinary: boolean;
    overrideBlink: VRMExpressionOverrideType;
    get overrideBlinkAmount(): number;
    overrideLookAt: VRMExpressionOverrideType;
    get overrideLookAtAmount(): number;
    overrideMouth: VRMExpressionOverrideType;
    get overrideMouthAmount(): number;
    // (undocumented)
    readonly type: string | 'VRMExpression';
    weight: number;
}

// @public (undocumented)
export interface VRMExpressionBind {
    applyWeight(weight: number): void;
    clearAppliedWeight(): void;
}

// @public
export class VRMExpressionLoaderPlugin implements GLTFLoaderPlugin {
    constructor(parser: GLTFParser);
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    // (undocumented)
    get name(): string;
    // (undocumented)
    readonly parser: GLTFParser;
    // Warning: (ae-forgotten-export) The symbol "V0VRM" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static readonly v0v1PresetNameMap: {
        [v0Name in V0VRM.BlendShapePresetName]?: VRMExpressionPresetName;
    };
}

// @public (undocumented)
export class VRMExpressionManager {
    constructor();
    blinkExpressionNames: string[];
    clone(): VRMExpressionManager;
    copy(source: VRMExpressionManager): this;
    get customExpressionMap(): {
        [name: string]: VRMExpression;
    };
    // (undocumented)
    get expressionMap(): {
        [name: string]: VRMExpression;
    };
    // (undocumented)
    get expressions(): VRMExpression[];
    getExpression(name: VRMExpressionPresetName | string): VRMExpression | null;
    getExpressionTrackName(name: VRMExpressionPresetName | string): string | null;
    getValue(name: VRMExpressionPresetName | string): number | null;
    lookAtExpressionNames: string[];
    mouthExpressionNames: string[];
    get presetExpressionMap(): {
        [name in VRMExpressionPresetName]?: VRMExpression;
    };
    registerExpression(expression: VRMExpression): void;
    setValue(name: VRMExpressionPresetName | string, weight: number): void;
    unregisterExpression(expression: VRMExpression): void;
    update(): void;
}

// @public
export class VRMExpressionMaterialColorBind implements VRMExpressionBind {
    constructor({ material, type, targetValue, }: {
        material: THREE_2.Material;
        type: VRMExpressionMaterialColorType;
        targetValue: THREE_2.Color;
    });
    // (undocumented)
    applyWeight(weight: number): void;
    // (undocumented)
    clearAppliedWeight(): void;
    readonly material: THREE_2.Material;
    readonly targetValue: THREE_2.Color;
    readonly type: VRMExpressionMaterialColorType;
}

// @public (undocumented)
export const VRMExpressionMaterialColorType: {
    readonly Color: "color";
    readonly EmissionColor: "emissionColor";
    readonly ShadeColor: "shadeColor";
    readonly MatcapColor: "matcapColor";
    readonly RimColor: "rimColor";
    readonly OutlineColor: "outlineColor";
};

// @public (undocumented)
export type VRMExpressionMaterialColorType = typeof VRMExpressionMaterialColorType[keyof typeof VRMExpressionMaterialColorType];

// @public
export class VRMExpressionMorphTargetBind implements VRMExpressionBind {
    constructor({ primitives, index, weight, }: {
        primitives: THREE_2.Mesh[];
        index: number;
        weight: number;
    });
    // (undocumented)
    applyWeight(weight: number): void;
    // (undocumented)
    clearAppliedWeight(): void;
    readonly index: number;
    readonly primitives: THREE_2.Mesh[];
    readonly weight: number;
}

// @public (undocumented)
export const VRMExpressionOverrideType: {
    readonly None: "none";
    readonly Block: "block";
    readonly Blend: "blend";
};

// @public (undocumented)
export type VRMExpressionOverrideType = typeof VRMExpressionOverrideType[keyof typeof VRMExpressionOverrideType];

// @public (undocumented)
export const VRMExpressionPresetName: {
    readonly Aa: "aa";
    readonly Ih: "ih";
    readonly Ou: "ou";
    readonly Ee: "ee";
    readonly Oh: "oh";
    readonly Blink: "blink";
    readonly Happy: "happy";
    readonly Angry: "angry";
    readonly Sad: "sad";
    readonly Relaxed: "relaxed";
    readonly LookUp: "lookUp";
    readonly Surprised: "surprised";
    readonly LookDown: "lookDown";
    readonly LookLeft: "lookLeft";
    readonly LookRight: "lookRight";
    readonly BlinkLeft: "blinkLeft";
    readonly BlinkRight: "blinkRight";
    readonly Neutral: "neutral";
};

// @public (undocumented)
export type VRMExpressionPresetName = typeof VRMExpressionPresetName[keyof typeof VRMExpressionPresetName];

// @public
export class VRMExpressionTextureTransformBind implements VRMExpressionBind {
    constructor({ material, scale, offset, }: {
        material: THREE_2.Material;
        scale: THREE_2.Vector2;
        offset: THREE_2.Vector2;
    });
    // (undocumented)
    applyWeight(weight: number): void;
    // (undocumented)
    clearAppliedWeight(): void;
    readonly material: THREE_2.Material;
    readonly offset: THREE_2.Vector2;
    readonly scale: THREE_2.Vector2;
}

// @public (undocumented)
export class VRMFirstPerson {
    constructor(humanoid: VRMHumanoid, meshAnnotations: VRMFirstPersonMeshAnnotation[]);
    clone(): VRMFirstPerson;
    copy(source: VRMFirstPerson): this;
    static readonly DEFAULT_FIRSTPERSON_ONLY_LAYER = 9;
    static readonly DEFAULT_THIRDPERSON_ONLY_LAYER = 10;
    get firstPersonOnlyLayer(): number;
    readonly humanoid: VRMHumanoid;
    // (undocumented)
    meshAnnotations: VRMFirstPersonMeshAnnotation[];
    setup({ firstPersonOnlyLayer, thirdPersonOnlyLayer, }?: {
        firstPersonOnlyLayer?: number | undefined;
        thirdPersonOnlyLayer?: number | undefined;
    }): void;
    get thirdPersonOnlyLayer(): number;
}

// @public
export class VRMFirstPersonLoaderPlugin implements GLTFLoaderPlugin {
    constructor(parser: GLTFParser);
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    // (undocumented)
    get name(): string;
    // (undocumented)
    readonly parser: GLTFParser;
}

// @public (undocumented)
export interface VRMFirstPersonMeshAnnotation {
    // (undocumented)
    meshes: THREE.Mesh[];
    // (undocumented)
    type: VRMFirstPersonMeshAnnotationType;
}

// @public (undocumented)
export const VRMFirstPersonMeshAnnotationType: {
    readonly Auto: "auto";
    readonly Both: "both";
    readonly ThirdPersonOnly: "thirdPersonOnly";
    readonly FirstPersonOnly: "firstPersonOnly";
};

// @public (undocumented)
export type VRMFirstPersonMeshAnnotationType = typeof VRMFirstPersonMeshAnnotationType[keyof typeof VRMFirstPersonMeshAnnotationType];

// @public
export interface VRMHumanBone {
    node: THREE_2.Object3D;
}

// @public
export const VRMHumanBoneList: VRMHumanBoneName[];

// @public
export const VRMHumanBoneName: {
    readonly Hips: "hips";
    readonly Spine: "spine";
    readonly Chest: "chest";
    readonly UpperChest: "upperChest";
    readonly Neck: "neck";
    readonly Head: "head";
    readonly LeftEye: "leftEye";
    readonly RightEye: "rightEye";
    readonly Jaw: "jaw";
    readonly LeftUpperLeg: "leftUpperLeg";
    readonly LeftLowerLeg: "leftLowerLeg";
    readonly LeftFoot: "leftFoot";
    readonly LeftToes: "leftToes";
    readonly RightUpperLeg: "rightUpperLeg";
    readonly RightLowerLeg: "rightLowerLeg";
    readonly RightFoot: "rightFoot";
    readonly RightToes: "rightToes";
    readonly LeftShoulder: "leftShoulder";
    readonly LeftUpperArm: "leftUpperArm";
    readonly LeftLowerArm: "leftLowerArm";
    readonly LeftHand: "leftHand";
    readonly RightShoulder: "rightShoulder";
    readonly RightUpperArm: "rightUpperArm";
    readonly RightLowerArm: "rightLowerArm";
    readonly RightHand: "rightHand";
    readonly LeftThumbMetacarpal: "leftThumbMetacarpal";
    readonly LeftThumbProximal: "leftThumbProximal";
    readonly LeftThumbDistal: "leftThumbDistal";
    readonly LeftIndexProximal: "leftIndexProximal";
    readonly LeftIndexIntermediate: "leftIndexIntermediate";
    readonly LeftIndexDistal: "leftIndexDistal";
    readonly LeftMiddleProximal: "leftMiddleProximal";
    readonly LeftMiddleIntermediate: "leftMiddleIntermediate";
    readonly LeftMiddleDistal: "leftMiddleDistal";
    readonly LeftRingProximal: "leftRingProximal";
    readonly LeftRingIntermediate: "leftRingIntermediate";
    readonly LeftRingDistal: "leftRingDistal";
    readonly LeftLittleProximal: "leftLittleProximal";
    readonly LeftLittleIntermediate: "leftLittleIntermediate";
    readonly LeftLittleDistal: "leftLittleDistal";
    readonly RightThumbMetacarpal: "rightThumbMetacarpal";
    readonly RightThumbProximal: "rightThumbProximal";
    readonly RightThumbDistal: "rightThumbDistal";
    readonly RightIndexProximal: "rightIndexProximal";
    readonly RightIndexIntermediate: "rightIndexIntermediate";
    readonly RightIndexDistal: "rightIndexDistal";
    readonly RightMiddleProximal: "rightMiddleProximal";
    readonly RightMiddleIntermediate: "rightMiddleIntermediate";
    readonly RightMiddleDistal: "rightMiddleDistal";
    readonly RightRingProximal: "rightRingProximal";
    readonly RightRingIntermediate: "rightRingIntermediate";
    readonly RightRingDistal: "rightRingDistal";
    readonly RightLittleProximal: "rightLittleProximal";
    readonly RightLittleIntermediate: "rightLittleIntermediate";
    readonly RightLittleDistal: "rightLittleDistal";
};

// @public (undocumented)
export type VRMHumanBoneName = typeof VRMHumanBoneName[keyof typeof VRMHumanBoneName];

// @public
export const VRMHumanBoneParentMap: {
    [bone in VRMHumanBoneName]: VRMHumanBoneName | null;
};

// @public
export type VRMHumanBones = {
    [name in VRMHumanBoneName]?: VRMHumanBone;
} & {
    [name in VRMRequiredHumanBoneName]: VRMHumanBone;
};

// @public
export class VRMHumanoid {
    constructor(humanBones: VRMHumanBones, options?: {
        autoUpdateHumanBones?: boolean;
    });
    autoUpdateHumanBones: boolean;
    clone(): VRMHumanoid;
    copy(source: VRMHumanoid): this;
    // @deprecated (undocumented)
    getAbsolutePose(): VRMPose;
    // @deprecated (undocumented)
    getBone(name: VRMHumanBoneName): VRMHumanBone | undefined;
    // @deprecated (undocumented)
    getBoneNode(name: VRMHumanBoneName): THREE_2.Object3D | null;
    getNormalizedAbsolutePose(): VRMPose;
    getNormalizedBone(name: VRMHumanBoneName): VRMHumanBone | undefined;
    getNormalizedBoneNode(name: VRMHumanBoneName): THREE_2.Object3D | null;
    getNormalizedPose(): VRMPose;
    // @deprecated (undocumented)
    getPose(): VRMPose;
    getRawAbsolutePose(): VRMPose;
    getRawBone(name: VRMHumanBoneName): VRMHumanBone | undefined;
    getRawBoneNode(name: VRMHumanBoneName): THREE_2.Object3D | null;
    getRawPose(): VRMPose;
    get humanBones(): VRMHumanBones;
    get normalizedHumanBones(): VRMHumanBones;
    get normalizedHumanBonesRoot(): THREE_2.Object3D;
    get normalizedRestPose(): VRMPose;
    get rawHumanBones(): VRMHumanBones;
    get rawRestPose(): VRMPose;
    resetNormalizedPose(): void;
    // @deprecated (undocumented)
    resetPose(): void;
    resetRawPose(): void;
    // @deprecated (undocumented)
    get restPose(): VRMPose;
    setNormalizedPose(poseObject: VRMPose): void;
    // @deprecated (undocumented)
    setPose(poseObject: VRMPose): void;
    setRawPose(poseObject: VRMPose): void;
    update(): void;
}

// @public (undocumented)
export class VRMHumanoidHelper extends THREE_2.Group {
    constructor(humanoid: VRMHumanoid);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    updateMatrixWorld(force: boolean): void;
    // (undocumented)
    readonly vrmHumanoid: VRMHumanoid;
}

// @public
export class VRMHumanoidLoaderPlugin implements GLTFLoaderPlugin {
    constructor(parser: GLTFParser, options?: VRMHumanoidLoaderPluginOptions);
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    // (undocumented)
    autoUpdateHumanBones?: boolean;
    helperRoot?: THREE.Object3D;
    // (undocumented)
    get name(): string;
    // (undocumented)
    readonly parser: GLTFParser;
}

// @public (undocumented)
export interface VRMHumanoidLoaderPluginOptions {
    autoUpdateHumanBones?: boolean;
    helperRoot?: THREE.Object3D;
}

// @public
export class VRMLookAt {
    constructor(humanoid: VRMHumanoid, applier: VRMLookAtApplier);
    applier: VRMLookAtApplier;
    autoUpdate: boolean;
    clone(): VRMLookAt;
    copy(source: VRMLookAt): this;
    // @deprecated (undocumented)
    get euler(): THREE_2.Euler;
    // (undocumented)
    static readonly EULER_ORDER = "YXZ";
    faceFront: THREE_2.Vector3;
    getEuler(target: THREE_2.Euler): THREE_2.Euler;
    getFaceFrontQuaternion(target: THREE_2.Quaternion): THREE_2.Quaternion;
    getLookAtWorldDirection(target: THREE_2.Vector3): THREE_2.Vector3;
    getLookAtWorldPosition(target: THREE_2.Vector3): THREE_2.Vector3;
    getLookAtWorldQuaternion(target: THREE_2.Quaternion): THREE_2.Quaternion;
    readonly humanoid: VRMHumanoid;
    lookAt(position: THREE_2.Vector3): void;
    protected _needsUpdate: boolean;
    offsetFromHeadBone: THREE_2.Vector3;
    get pitch(): number;
    set pitch(value: number);
    protected _pitch: number;
    reset(): void;
    target?: THREE_2.Object3D | null;
    update(delta: number): void;
    get yaw(): number;
    set yaw(value: number);
    protected _yaw: number;
}

// @public
export interface VRMLookAtApplier {
    applyYawPitch: (yaw: number, pitch: number) => void;
    // @deprecated (undocumented)
    lookAt: (euler: THREE_2.Euler) => void;
}

// @public
export class VRMLookAtBoneApplier implements VRMLookAtApplier {
    constructor(humanoid: VRMHumanoid, rangeMapHorizontalInner: VRMLookAtRangeMap, rangeMapHorizontalOuter: VRMLookAtRangeMap, rangeMapVerticalDown: VRMLookAtRangeMap, rangeMapVerticalUp: VRMLookAtRangeMap);
    applyYawPitch(yaw: number, pitch: number): void;
    faceFront: THREE_2.Vector3;
    readonly humanoid: VRMHumanoid;
    // @deprecated (undocumented)
    lookAt(euler: THREE_2.Euler): void;
    rangeMapHorizontalInner: VRMLookAtRangeMap;
    rangeMapHorizontalOuter: VRMLookAtRangeMap;
    rangeMapVerticalDown: VRMLookAtRangeMap;
    rangeMapVerticalUp: VRMLookAtRangeMap;
    static readonly type = "bone";
}

// @public
export class VRMLookAtExpressionApplier implements VRMLookAtApplier {
    constructor(expressions: VRMExpressionManager, rangeMapHorizontalInner: VRMLookAtRangeMap, rangeMapHorizontalOuter: VRMLookAtRangeMap, rangeMapVerticalDown: VRMLookAtRangeMap, rangeMapVerticalUp: VRMLookAtRangeMap);
    applyYawPitch(yaw: number, pitch: number): void;
    readonly expressions: VRMExpressionManager;
    // @deprecated (undocumented)
    lookAt(euler: THREE_2.Euler): void;
    rangeMapHorizontalInner: VRMLookAtRangeMap;
    rangeMapHorizontalOuter: VRMLookAtRangeMap;
    rangeMapVerticalDown: VRMLookAtRangeMap;
    rangeMapVerticalUp: VRMLookAtRangeMap;
    static readonly type = "expression";
}

// @public (undocumented)
export class VRMLookAtHelper extends THREE_2.Group {
    constructor(lookAt: VRMLookAt);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    updateMatrixWorld(force: boolean): void;
    // (undocumented)
    readonly vrmLookAt: VRMLookAt;
}

// @public
export class VRMLookAtLoaderPlugin implements GLTFLoaderPlugin {
    // Warning: (ae-forgotten-export) The symbol "VRMLookAtLoaderPluginOptions" needs to be exported by the entry point index.d.ts
    constructor(parser: GLTFParser, options?: VRMLookAtLoaderPluginOptions);
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    helperRoot?: THREE.Object3D;
    // (undocumented)
    get name(): string;
    // (undocumented)
    readonly parser: GLTFParser;
}

// @public (undocumented)
export class VRMLookAtRangeMap {
    constructor(inputMaxValue: number, outputScale: number);
    inputMaxValue: number;
    map(src: number): number;
    outputScale: number;
}

// @public
export const VRMLookAtTypeName: {
    Bone: string;
    Expression: string;
};

// @public (undocumented)
export type VRMLookAtTypeName = typeof VRMLookAtTypeName[keyof typeof VRMLookAtTypeName];

// @public
export type VRMMeta = VRM0Meta | VRM1Meta;

// @public
export interface VRMMetaImporterOptions {
    acceptLicenseUrls?: string[];
    acceptV0Meta?: boolean;
    needThumbnailImage?: boolean;
}

// @public
export class VRMMetaLoaderPlugin implements GLTFLoaderPlugin {
    constructor(parser: GLTFParser, options?: VRMMetaImporterOptions);
    acceptLicenseUrls: string[];
    acceptV0Meta: boolean;
    // (undocumented)
    afterRoot(gltf: GLTF): Promise<void>;
    // (undocumented)
    get name(): string;
    needThumbnailImage: boolean;
    // (undocumented)
    readonly parser: GLTFParser;
}

// @public
export type VRMPose = {
    [boneName in VRMHumanBoneName]?: VRMPoseTransform;
};

// @public
export interface VRMPoseTransform {
    position?: [number, number, number];
    rotation?: [number, number, number, number];
}

// @public (undocumented)
export const VRMRequiredHumanBoneName: {
    readonly Hips: "hips";
    readonly Spine: "spine";
    readonly Head: "head";
    readonly LeftUpperLeg: "leftUpperLeg";
    readonly LeftLowerLeg: "leftLowerLeg";
    readonly LeftFoot: "leftFoot";
    readonly RightUpperLeg: "rightUpperLeg";
    readonly RightLowerLeg: "rightLowerLeg";
    readonly RightFoot: "rightFoot";
    readonly LeftUpperArm: "leftUpperArm";
    readonly LeftLowerArm: "leftLowerArm";
    readonly LeftHand: "leftHand";
    readonly RightUpperArm: "rightUpperArm";
    readonly RightLowerArm: "rightLowerArm";
    readonly RightHand: "rightHand";
};

// @public (undocumented)
export type VRMRequiredHumanBoneName = typeof VRMRequiredHumanBoneName[keyof typeof VRMRequiredHumanBoneName];

// (No @packageDocumentation comment for this package)

```
