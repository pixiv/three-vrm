/*! (c) 2020-2024 pixiv Inc. - https://github.com/pixiv/three-vrm/blob/release/LICENSE */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).THREE_VRM_CORE={},e.THREE)}(this,(function(e,t){"use strict";function i(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(i){if("default"!==i){var r=Object.getOwnPropertyDescriptor(e,i);Object.defineProperty(t,i,r.get?r:{enumerable:!0,get:function(){return e[i]}})}})),t.default=e,Object.freeze(t)}var r=i(t);class o extends r.Object3D{get overrideBlinkAmount(){return"block"===this.overrideBlink?0<this.weight?1:0:"blend"===this.overrideBlink?this.weight:0}get overrideLookAtAmount(){return"block"===this.overrideLookAt?0<this.weight?1:0:"blend"===this.overrideLookAt?this.weight:0}get overrideMouthAmount(){return"block"===this.overrideMouth?0<this.weight?1:0:"blend"===this.overrideMouth?this.weight:0}constructor(e){super(),this.weight=0,this.isBinary=!1,this.overrideBlink="none",this.overrideLookAt="none",this.overrideMouth="none",this._binds=[],this.name=`VRMExpression_${e}`,this.expressionName=e,this.type="VRMExpression",this.visible=!1}addBind(e){this._binds.push(e)}applyWeight(e){var t;let i=this.isBinary?this.weight<=.5?0:1:this.weight;i*=null!==(t=null==e?void 0:e.multiplier)&&void 0!==t?t:1,this._binds.forEach((e=>e.applyWeight(i)))}clearAppliedWeight(){this._binds.forEach((e=>e.clearAppliedWeight()))}}function n(e,t,i,r){return new(i||(i=Promise))((function(o,n){function s(e){try{l(r.next(e))}catch(e){n(e)}}function a(e){try{l(r.throw(e))}catch(e){n(e)}}function l(e){var t;e.done?o(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(s,a)}l((r=r.apply(e,t||[])).next())}))}function s(e,t,i){var r,o;const n=e.parser.json,s=null===(r=n.nodes)||void 0===r?void 0:r[t];if(null==s)return console.warn(`extractPrimitivesInternal: Attempt to use nodes[${t}] of glTF but the node doesn't exist`),null;const a=s.mesh;if(null==a)return null;const l=null===(o=n.meshes)||void 0===o?void 0:o[a];if(null==l)return console.warn(`extractPrimitivesInternal: Attempt to use meshes[${a}] of glTF but the mesh doesn't exist`),null;const h=l.primitives.length,u=[];return i.traverse((e=>{u.length<h&&e.isMesh&&u.push(e)})),u}function a(e,t){return n(this,void 0,void 0,(function*(){const i=yield e.parser.getDependency("node",t);return s(e,t,i)}))}function l(e){return n(this,void 0,void 0,(function*(){const t=yield e.parser.getDependencies("node"),i=new Map;return t.forEach(((t,r)=>{const o=s(e,r,t);null!=o&&i.set(r,o)})),i}))}function h(e,t){var i,o;let n=null;if(parseInt(r.REVISION,10)>=133)n=null!==(o=null===(i=e.associations.get(t))||void 0===i?void 0:i.materials)&&void 0!==o?o:null;else{const i=e.associations.get(t);"materials"===(null==i?void 0:i.type)&&(n=i.index)}return n}"function"==typeof SuppressedError&&SuppressedError;const u={Aa:"aa",Ih:"ih",Ou:"ou",Ee:"ee",Oh:"oh",Blink:"blink",Happy:"happy",Angry:"angry",Sad:"sad",Relaxed:"relaxed",LookUp:"lookUp",Surprised:"surprised",LookDown:"lookDown",LookLeft:"lookLeft",LookRight:"lookRight",BlinkLeft:"blinkLeft",BlinkRight:"blinkRight",Neutral:"neutral"};function d(e){return Math.max(Math.min(e,1),0)}class p{get expressions(){return this._expressions.concat()}get expressionMap(){return Object.assign({},this._expressionMap)}get presetExpressionMap(){const e={},t=new Set(Object.values(u));return Object.entries(this._expressionMap).forEach((([i,r])=>{t.has(i)&&(e[i]=r)})),e}get customExpressionMap(){const e={},t=new Set(Object.values(u));return Object.entries(this._expressionMap).forEach((([i,r])=>{t.has(i)||(e[i]=r)})),e}constructor(){this.blinkExpressionNames=["blink","blinkLeft","blinkRight"],this.lookAtExpressionNames=["lookLeft","lookRight","lookUp","lookDown"],this.mouthExpressionNames=["aa","ee","ih","oh","ou"],this._expressions=[],this._expressionMap={}}copy(e){return this._expressions.concat().forEach((e=>{this.unregisterExpression(e)})),e._expressions.forEach((e=>{this.registerExpression(e)})),this.blinkExpressionNames=e.blinkExpressionNames.concat(),this.lookAtExpressionNames=e.lookAtExpressionNames.concat(),this.mouthExpressionNames=e.mouthExpressionNames.concat(),this}clone(){return(new p).copy(this)}getExpression(e){var t;return null!==(t=this._expressionMap[e])&&void 0!==t?t:null}registerExpression(e){this._expressions.push(e),this._expressionMap[e.expressionName]=e}unregisterExpression(e){const t=this._expressions.indexOf(e);-1===t&&console.warn("VRMExpressionManager: The specified expressions is not registered"),this._expressions.splice(t,1),delete this._expressionMap[e.expressionName]}getValue(e){var t;const i=this.getExpression(e);return null!==(t=null==i?void 0:i.weight)&&void 0!==t?t:null}setValue(e,t){const i=this.getExpression(e);i&&(i.weight=d(t))}getExpressionTrackName(e){const t=this.getExpression(e);return t?`${t.name}.weight`:null}update(){const e=this._calculateWeightMultipliers();this._expressions.forEach((e=>{e.clearAppliedWeight()})),this._expressions.forEach((t=>{let i=1;const r=t.expressionName;-1!==this.blinkExpressionNames.indexOf(r)&&(i*=e.blink),-1!==this.lookAtExpressionNames.indexOf(r)&&(i*=e.lookAt),-1!==this.mouthExpressionNames.indexOf(r)&&(i*=e.mouth),t.applyWeight({multiplier:i})}))}_calculateWeightMultipliers(){let e=1,t=1,i=1;return this._expressions.forEach((r=>{e-=r.overrideBlinkAmount,t-=r.overrideLookAtAmount,i-=r.overrideMouthAmount})),e=Math.max(0,e),t=Math.max(0,t),i=Math.max(0,i),{blink:e,lookAt:t,mouth:i}}}const c={Color:"color",EmissionColor:"emissionColor",ShadeColor:"shadeColor",MatcapColor:"matcapColor",RimColor:"rimColor",OutlineColor:"outlineColor"},m={_Color:c.Color,_EmissionColor:c.EmissionColor,_ShadeColor:c.ShadeColor,_RimColor:c.RimColor,_OutlineColor:c.OutlineColor},g=new r.Color;class f{constructor({material:e,type:t,targetValue:i,targetAlpha:r}){this.material=e,this.type=t,this.targetValue=i,this.targetAlpha=null!=r?r:1;const o=this._initColorBindState(),n=this._initAlphaBindState();this._state={color:o,alpha:n}}applyWeight(e){const{color:t,alpha:i}=this._state;if(null!=t){const{propertyName:i,deltaValue:r}=t,o=this.material[i];null!=o&&o.add(g.copy(r).multiplyScalar(e))}if(null!=i){const{propertyName:t,deltaValue:r}=i;null!=this.material[t]&&(this.material[t]+=r*e)}}clearAppliedWeight(){const{color:e,alpha:t}=this._state;if(null!=e){const{propertyName:t,initialValue:i}=e,r=this.material[t];null!=r&&r.copy(i)}if(null!=t){const{propertyName:e,initialValue:i}=t;null!=this.material[e]&&(this.material[e]=i)}}_initColorBindState(){var e,t,i;const{material:o,type:n,targetValue:s}=this,a=this._getPropertyNameMap(),l=null!==(t=null===(e=null==a?void 0:a[n])||void 0===e?void 0:e[0])&&void 0!==t?t:null;if(null==l)return console.warn(`Tried to add a material color bind to the material ${null!==(i=o.name)&&void 0!==i?i:"(no name)"}, the type ${n} but the material or the type is not supported.`),null;const h=o[l].clone();return{propertyName:l,initialValue:h,deltaValue:new r.Color(s.r-h.r,s.g-h.g,s.b-h.b)}}_initAlphaBindState(){var e,t,i;const{material:r,type:o,targetAlpha:n}=this,s=this._getPropertyNameMap(),a=null!==(t=null===(e=null==s?void 0:s[o])||void 0===e?void 0:e[1])&&void 0!==t?t:null;if(null==a&&1!==n)return console.warn(`Tried to add a material alpha bind to the material ${null!==(i=r.name)&&void 0!==i?i:"(no name)"}, the type ${o} but the material or the type does not support alpha.`),null;if(null==a)return null;const l=r[a];return{propertyName:a,initialValue:l,deltaValue:n-l}}_getPropertyNameMap(){var e,t;return null!==(t=null===(e=Object.entries(f._propertyNameMapMap).find((([e])=>!0===this.material[e])))||void 0===e?void 0:e[1])&&void 0!==t?t:null}}f._propertyNameMapMap={isMeshStandardMaterial:{color:["color","opacity"],emissionColor:["emissive",null]},isMeshBasicMaterial:{color:["color","opacity"]},isMToonMaterial:{color:["color","opacity"],emissionColor:["emissive",null],outlineColor:["outlineColorFactor",null],matcapColor:["matcapFactor",null],rimColor:["parametricRimColorFactor",null],shadeColor:["shadeColorFactor",null]}};class v{constructor({primitives:e,index:t,weight:i}){this.primitives=e,this.index=t,this.weight=i}applyWeight(e){this.primitives.forEach((t=>{var i;null!=(null===(i=t.morphTargetInfluences)||void 0===i?void 0:i[this.index])&&(t.morphTargetInfluences[this.index]+=this.weight*e)}))}clearAppliedWeight(){this.primitives.forEach((e=>{var t;null!=(null===(t=e.morphTargetInfluences)||void 0===t?void 0:t[this.index])&&(e.morphTargetInfluences[this.index]=0)}))}}const y=new r.Vector2;class M{constructor({material:e,scale:t,offset:i}){var r,o;this.material=e,this.scale=t,this.offset=i;const n=null===(r=Object.entries(M._propertyNamesMap).find((([t])=>!0===e[t])))||void 0===r?void 0:r[1];null==n?(console.warn(`Tried to add a texture transform bind to the material ${null!==(o=e.name)&&void 0!==o?o:"(no name)"} but the material is not supported.`),this._properties=[]):(this._properties=[],n.forEach((r=>{var o;const n=null===(o=e[r])||void 0===o?void 0:o.clone();if(!n)return null;e[r]=n;const s=n.offset.clone(),a=n.repeat.clone(),l=i.clone().sub(s),h=t.clone().sub(a);this._properties.push({name:r,initialOffset:s,deltaOffset:l,initialScale:a,deltaScale:h})})))}applyWeight(e){this._properties.forEach((t=>{const i=this.material[t.name];void 0!==i&&(i.offset.add(y.copy(t.deltaOffset).multiplyScalar(e)),i.repeat.add(y.copy(t.deltaScale).multiplyScalar(e)))}))}clearAppliedWeight(){this._properties.forEach((e=>{const t=this.material[e.name];void 0!==t&&(t.offset.copy(e.initialOffset),t.repeat.copy(e.initialScale))}))}}M._propertyNamesMap={isMeshStandardMaterial:["map","emissiveMap","bumpMap","normalMap","displacementMap","roughnessMap","metalnessMap","alphaMap"],isMeshBasicMaterial:["map","specularMap","alphaMap"],isMToonMaterial:["map","normalMap","emissiveMap","shadeMultiplyTexture","rimMultiplyTexture","outlineWidthMultiplyTexture","uvAnimationMaskTexture"]};const x=new Set(["1.0","1.0-beta"]);class w{get name(){return"VRMExpressionLoaderPlugin"}constructor(e){this.parser=e}afterRoot(e){return n(this,void 0,void 0,(function*(){e.userData.vrmExpressionManager=yield this._import(e)}))}_import(e){return n(this,void 0,void 0,(function*(){const t=yield this._v1Import(e);if(t)return t;const i=yield this._v0Import(e);return i||null}))}_v1Import(e){var t,i;return n(this,void 0,void 0,(function*(){const s=this.parser.json;if(!(-1!==(null===(t=s.extensionsUsed)||void 0===t?void 0:t.indexOf("VRMC_vrm"))))return null;const l=null===(i=s.extensions)||void 0===i?void 0:i.VRMC_vrm;if(!l)return null;const d=l.specVersion;if(!x.has(d))return console.warn(`VRMExpressionLoaderPlugin: Unknown VRMC_vrm specVersion "${d}"`),null;const c=l.expressions;if(!c)return null;const m=new Set(Object.values(u)),g=new Map;null!=c.preset&&Object.entries(c.preset).forEach((([e,t])=>{null!=t&&(m.has(e)?g.set(e,t):console.warn(`VRMExpressionLoaderPlugin: Unknown preset name "${e}" detected. Ignoring the expression`))})),null!=c.custom&&Object.entries(c.custom).forEach((([e,t])=>{m.has(e)?console.warn(`VRMExpressionLoaderPlugin: Custom expression cannot have preset name "${e}". Ignoring the expression`):g.set(e,t)}));const y=new p;return yield Promise.all(Array.from(g.entries()).map((([t,i])=>n(this,void 0,void 0,(function*(){var s,l,u,d,p,c,m;const g=new o(t);if(e.scene.add(g),g.isBinary=null!==(s=i.isBinary)&&void 0!==s&&s,g.overrideBlink=null!==(l=i.overrideBlink)&&void 0!==l?l:"none",g.overrideLookAt=null!==(u=i.overrideLookAt)&&void 0!==u?u:"none",g.overrideMouth=null!==(d=i.overrideMouth)&&void 0!==d?d:"none",null===(p=i.morphTargetBinds)||void 0===p||p.forEach((t=>n(this,void 0,void 0,(function*(){var r;if(void 0===t.node||void 0===t.index)return;const o=yield a(e,t.node),n=t.index;o.every((e=>Array.isArray(e.morphTargetInfluences)&&n<e.morphTargetInfluences.length))?g.addBind(new v({primitives:o,index:n,weight:null!==(r=t.weight)&&void 0!==r?r:1})):console.warn(`VRMExpressionLoaderPlugin: ${i.name} attempts to index morph #${n} but not found.`)})))),i.materialColorBinds||i.textureTransformBinds){const t=[];e.scene.traverse((e=>{const i=e.material;i&&t.push(i)})),null===(c=i.materialColorBinds)||void 0===c||c.forEach((e=>n(this,void 0,void 0,(function*(){t.filter((t=>{const i=h(this.parser,t);return e.material===i})).forEach((t=>{g.addBind(new f({material:t,type:e.type,targetValue:(new r.Color).fromArray(e.targetValue),targetAlpha:e.targetValue[3]}))}))})))),null===(m=i.textureTransformBinds)||void 0===m||m.forEach((e=>n(this,void 0,void 0,(function*(){t.filter((t=>{const i=h(this.parser,t);return e.material===i})).forEach((t=>{var i,o;g.addBind(new M({material:t,offset:(new r.Vector2).fromArray(null!==(i=e.offset)&&void 0!==i?i:[0,0]),scale:(new r.Vector2).fromArray(null!==(o=e.scale)&&void 0!==o?o:[1,1])}))}))}))))}y.registerExpression(g)}))))),y}))}_v0Import(e){var t;return n(this,void 0,void 0,(function*(){const i=this.parser.json,s=null===(t=i.extensions)||void 0===t?void 0:t.VRM;if(!s)return null;const l=s.blendShapeMaster;if(!l)return null;const h=new p,u=l.blendShapeGroups;if(!u)return h;const d=new Set;return yield Promise.all(u.map((t=>n(this,void 0,void 0,(function*(){var s;const l=t.presetName,u=null!=l&&w.v0v1PresetNameMap[l]||null,p=null!=u?u:t.name;if(null==p)return void console.warn("VRMExpressionLoaderPlugin: One of custom expressions has no name. Ignoring the expression");if(d.has(p))return void console.warn(`VRMExpressionLoaderPlugin: An expression preset ${l} has duplicated entries. Ignoring the expression`);d.add(p);const c=new o(p);e.scene.add(c),c.isBinary=null!==(s=t.isBinary)&&void 0!==s&&s,t.binds&&t.binds.forEach((r=>n(this,void 0,void 0,(function*(){var o;if(void 0===r.mesh||void 0===r.index)return;const s=[];null===(o=i.nodes)||void 0===o||o.forEach(((e,t)=>{e.mesh===r.mesh&&s.push(t)}));const l=r.index;yield Promise.all(s.map((i=>n(this,void 0,void 0,(function*(){var o;const n=yield a(e,i);n.every((e=>Array.isArray(e.morphTargetInfluences)&&l<e.morphTargetInfluences.length))?c.addBind(new v({primitives:n,index:l,weight:.01*(null!==(o=r.weight)&&void 0!==o?o:100)})):console.warn(`VRMExpressionLoaderPlugin: ${t.name} attempts to index ${l}th morph but not found.`)})))))}))));const g=t.materialValues;g&&0!==g.length&&g.forEach((t=>{if(void 0===t.materialName||void 0===t.propertyName||void 0===t.targetValue)return;const i=[];e.scene.traverse((e=>{if(e.material){const r=e.material;Array.isArray(r)?i.push(...r.filter((e=>(e.name===t.materialName||e.name===t.materialName+" (Outline)")&&-1===i.indexOf(e)))):r.name===t.materialName&&-1===i.indexOf(r)&&i.push(r)}}));const o=t.propertyName;i.forEach((e=>{if("_MainTex_ST"===o){const i=new r.Vector2(t.targetValue[0],t.targetValue[1]),o=new r.Vector2(t.targetValue[2],t.targetValue[3]);return o.y=1-o.y-i.y,void c.addBind(new M({material:e,scale:i,offset:o}))}const i=m[o];i?c.addBind(new f({material:e,type:i,targetValue:(new r.Color).fromArray(t.targetValue),targetAlpha:t.targetValue[3]})):console.warn(o+" is not supported")}))})),h.registerExpression(c)}))))),h}))}}w.v0v1PresetNameMap={a:"aa",e:"ee",i:"ih",o:"oh",u:"ou",blink:"blink",joy:"happy",angry:"angry",sorrow:"sad",fun:"relaxed",lookup:"lookUp",lookdown:"lookDown",lookleft:"lookLeft",lookright:"lookRight",blink_l:"blinkLeft",blink_r:"blinkRight",neutral:"neutral"};class _{constructor(e,t){this._firstPersonOnlyLayer=_.DEFAULT_FIRSTPERSON_ONLY_LAYER,this._thirdPersonOnlyLayer=_.DEFAULT_THIRDPERSON_ONLY_LAYER,this._initializedLayers=!1,this.humanoid=e,this.meshAnnotations=t}copy(e){if(this.humanoid!==e.humanoid)throw new Error("VRMFirstPerson: humanoid must be same in order to copy");return this.meshAnnotations=e.meshAnnotations.map((e=>({meshes:e.meshes.concat(),type:e.type}))),this}clone(){return new _(this.humanoid,this.meshAnnotations).copy(this)}get firstPersonOnlyLayer(){return this._firstPersonOnlyLayer}get thirdPersonOnlyLayer(){return this._thirdPersonOnlyLayer}setup({firstPersonOnlyLayer:e=_.DEFAULT_FIRSTPERSON_ONLY_LAYER,thirdPersonOnlyLayer:t=_.DEFAULT_THIRDPERSON_ONLY_LAYER}={}){this._initializedLayers||(this._firstPersonOnlyLayer=e,this._thirdPersonOnlyLayer=t,this.meshAnnotations.forEach((e=>{e.meshes.forEach((t=>{"firstPersonOnly"===e.type?(t.layers.set(this._firstPersonOnlyLayer),t.traverse((e=>e.layers.set(this._firstPersonOnlyLayer)))):"thirdPersonOnly"===e.type?(t.layers.set(this._thirdPersonOnlyLayer),t.traverse((e=>e.layers.set(this._thirdPersonOnlyLayer)))):"auto"===e.type&&this._createHeadlessModel(t)}))})),this._initializedLayers=!0)}_excludeTriangles(e,t,i,r){let o=0;if(null!=t&&t.length>0)for(let n=0;n<e.length;n+=3){const s=e[n],a=e[n+1],l=e[n+2],h=t[s],u=i[s];if(h[0]>0&&r.includes(u[0]))continue;if(h[1]>0&&r.includes(u[1]))continue;if(h[2]>0&&r.includes(u[2]))continue;if(h[3]>0&&r.includes(u[3]))continue;const d=t[a],p=i[a];if(d[0]>0&&r.includes(p[0]))continue;if(d[1]>0&&r.includes(p[1]))continue;if(d[2]>0&&r.includes(p[2]))continue;if(d[3]>0&&r.includes(p[3]))continue;const c=t[l],m=i[l];c[0]>0&&r.includes(m[0])||(c[1]>0&&r.includes(m[1])||c[2]>0&&r.includes(m[2])||c[3]>0&&r.includes(m[3])||(e[o++]=s,e[o++]=a,e[o++]=l))}return o}_createErasedMesh(e,t){const i=new r.SkinnedMesh(e.geometry.clone(),e.material);i.name=`${e.name}(erase)`,i.frustumCulled=e.frustumCulled,i.layers.set(this._firstPersonOnlyLayer);const o=i.geometry,n=o.getAttribute("skinIndex"),s=n instanceof r.GLBufferAttribute?[]:n.array,a=[];for(let e=0;e<s.length;e+=4)a.push([s[e],s[e+1],s[e+2],s[e+3]]);const l=o.getAttribute("skinWeight"),h=l instanceof r.GLBufferAttribute?[]:l.array,u=[];for(let e=0;e<h.length;e+=4)u.push([h[e],h[e+1],h[e+2],h[e+3]]);const d=o.getIndex();if(!d)throw new Error("The geometry doesn't have an index buffer");const p=Array.from(d.array),c=this._excludeTriangles(p,u,a,t),m=[];for(let e=0;e<c;e++)m[e]=p[e];return o.setIndex(m),e.onBeforeRender&&(i.onBeforeRender=e.onBeforeRender),i.bind(new r.Skeleton(e.skeleton.bones,e.skeleton.boneInverses),new r.Matrix4),i}_createHeadlessModelForSkinnedMesh(e,t){const i=[];if(t.skeleton.bones.forEach(((e,t)=>{this._isEraseTarget(e)&&i.push(t)})),!i.length)return t.layers.enable(this._thirdPersonOnlyLayer),void t.layers.enable(this._firstPersonOnlyLayer);t.layers.set(this._thirdPersonOnlyLayer);const r=this._createErasedMesh(t,i);e.add(r)}_createHeadlessModel(e){if("Group"===e.type)if(e.layers.set(this._thirdPersonOnlyLayer),this._isEraseTarget(e))e.traverse((e=>e.layers.set(this._thirdPersonOnlyLayer)));else{const t=new r.Group;t.name=`_headless_${e.name}`,t.layers.set(this._firstPersonOnlyLayer),e.parent.add(t),e.children.filter((e=>"SkinnedMesh"===e.type)).forEach((e=>{const i=e;this._createHeadlessModelForSkinnedMesh(t,i)}))}else if("SkinnedMesh"===e.type){const t=e;this._createHeadlessModelForSkinnedMesh(e.parent,t)}else this._isEraseTarget(e)&&(e.layers.set(this._thirdPersonOnlyLayer),e.traverse((e=>e.layers.set(this._thirdPersonOnlyLayer))))}_isEraseTarget(e){return e===this.humanoid.getRawBoneNode("head")||!!e.parent&&this._isEraseTarget(e.parent)}}_.DEFAULT_FIRSTPERSON_ONLY_LAYER=9,_.DEFAULT_THIRDPERSON_ONLY_LAYER=10;const R=new Set(["1.0","1.0-beta"]);class P{get name(){return"VRMFirstPersonLoaderPlugin"}constructor(e){this.parser=e}afterRoot(e){return n(this,void 0,void 0,(function*(){const t=e.userData.vrmHumanoid;if(null!==t){if(void 0===t)throw new Error("VRMFirstPersonLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");e.userData.vrmFirstPerson=yield this._import(e,t)}}))}_import(e,t){return n(this,void 0,void 0,(function*(){if(null==t)return null;const i=yield this._v1Import(e,t);if(i)return i;const r=yield this._v0Import(e,t);return r||null}))}_v1Import(e,t){var i,r;return n(this,void 0,void 0,(function*(){const o=this.parser.json;if(!(-1!==(null===(i=o.extensionsUsed)||void 0===i?void 0:i.indexOf("VRMC_vrm"))))return null;const n=null===(r=o.extensions)||void 0===r?void 0:r.VRMC_vrm;if(!n)return null;const s=n.specVersion;if(!R.has(s))return console.warn(`VRMFirstPersonLoaderPlugin: Unknown VRMC_vrm specVersion "${s}"`),null;const a=n.firstPerson;if(!a)return null;const h=[],u=yield l(e);return Array.from(u.entries()).forEach((([e,t])=>{var i;const r=a.meshAnnotations?a.meshAnnotations.find((t=>t.node===e)):void 0;h.push({meshes:t,type:null!==(i=null==r?void 0:r.type)&&void 0!==i?i:"both"})})),new _(t,h)}))}_v0Import(e,t){var i;return n(this,void 0,void 0,(function*(){const r=this.parser.json,o=null===(i=r.extensions)||void 0===i?void 0:i.VRM;if(!o)return null;const n=o.firstPerson;if(!n)return null;const s=[],a=yield l(e);return Array.from(a.entries()).forEach((([e,t])=>{const i=r.nodes[e],o=n.meshAnnotations?n.meshAnnotations.find((e=>e.mesh===i.mesh)):void 0;s.push({meshes:t,type:this._convertV0FlagToV1Type(null==o?void 0:o.firstPersonFlag)})})),new _(t,s)}))}_convertV0FlagToV1Type(e){return"FirstPersonOnly"===e?"firstPersonOnly":"ThirdPersonOnly"===e?"thirdPersonOnly":"Auto"===e?"auto":"both"}}const L=new r.Vector3,A=new r.Vector3,b=new r.Quaternion;class E extends r.Group{constructor(e){super(),this.vrmHumanoid=e,this._boneAxesMap=new Map,Object.values(e.humanBones).forEach((e=>{const t=new r.AxesHelper(1);t.matrixAutoUpdate=!1,t.material.depthTest=!1,t.material.depthWrite=!1,this.add(t),this._boneAxesMap.set(e,t)}))}dispose(){Array.from(this._boneAxesMap.values()).forEach((e=>{e.geometry.dispose(),e.material.dispose()}))}updateMatrixWorld(e){Array.from(this._boneAxesMap.entries()).forEach((([e,t])=>{e.node.updateWorldMatrix(!0,!1),e.node.matrixWorld.decompose(L,b,A);const i=L.set(.1,.1,.1).divide(A);t.matrix.copy(e.node.matrixWorld).scale(i)})),super.updateMatrixWorld(e)}}const V=["hips","spine","chest","upperChest","neck","head","leftEye","rightEye","jaw","leftUpperLeg","leftLowerLeg","leftFoot","leftToes","rightUpperLeg","rightLowerLeg","rightFoot","rightToes","leftShoulder","leftUpperArm","leftLowerArm","leftHand","rightShoulder","rightUpperArm","rightLowerArm","rightHand","leftThumbMetacarpal","leftThumbProximal","leftThumbDistal","leftIndexProximal","leftIndexIntermediate","leftIndexDistal","leftMiddleProximal","leftMiddleIntermediate","leftMiddleDistal","leftRingProximal","leftRingIntermediate","leftRingDistal","leftLittleProximal","leftLittleIntermediate","leftLittleDistal","rightThumbMetacarpal","rightThumbProximal","rightThumbDistal","rightIndexProximal","rightIndexIntermediate","rightIndexDistal","rightMiddleProximal","rightMiddleIntermediate","rightMiddleDistal","rightRingProximal","rightRingIntermediate","rightRingDistal","rightLittleProximal","rightLittleIntermediate","rightLittleDistal"],B={hips:null,spine:"hips",chest:"spine",upperChest:"chest",neck:"upperChest",head:"neck",leftEye:"head",rightEye:"head",jaw:"head",leftUpperLeg:"hips",leftLowerLeg:"leftUpperLeg",leftFoot:"leftLowerLeg",leftToes:"leftFoot",rightUpperLeg:"hips",rightLowerLeg:"rightUpperLeg",rightFoot:"rightLowerLeg",rightToes:"rightFoot",leftShoulder:"upperChest",leftUpperArm:"leftShoulder",leftLowerArm:"leftUpperArm",leftHand:"leftLowerArm",rightShoulder:"upperChest",rightUpperArm:"rightShoulder",rightLowerArm:"rightUpperArm",rightHand:"rightLowerArm",leftThumbMetacarpal:"leftHand",leftThumbProximal:"leftThumbMetacarpal",leftThumbDistal:"leftThumbProximal",leftIndexProximal:"leftHand",leftIndexIntermediate:"leftIndexProximal",leftIndexDistal:"leftIndexIntermediate",leftMiddleProximal:"leftHand",leftMiddleIntermediate:"leftMiddleProximal",leftMiddleDistal:"leftMiddleIntermediate",leftRingProximal:"leftHand",leftRingIntermediate:"leftRingProximal",leftRingDistal:"leftRingIntermediate",leftLittleProximal:"leftHand",leftLittleIntermediate:"leftLittleProximal",leftLittleDistal:"leftLittleIntermediate",rightThumbMetacarpal:"rightHand",rightThumbProximal:"rightThumbMetacarpal",rightThumbDistal:"rightThumbProximal",rightIndexProximal:"rightHand",rightIndexIntermediate:"rightIndexProximal",rightIndexDistal:"rightIndexIntermediate",rightMiddleProximal:"rightHand",rightMiddleIntermediate:"rightMiddleProximal",rightMiddleDistal:"rightMiddleIntermediate",rightRingProximal:"rightHand",rightRingIntermediate:"rightRingProximal",rightRingDistal:"rightRingIntermediate",rightLittleProximal:"rightHand",rightLittleIntermediate:"rightLittleProximal",rightLittleDistal:"rightLittleIntermediate"};function I(e){return e.invert?e.invert():e.inverse(),e}const k=new r.Vector3,T=new r.Quaternion;class U{constructor(e){this.humanBones=e,this.restPose=this.getAbsolutePose()}getAbsolutePose(){const e={};return Object.keys(this.humanBones).forEach((t=>{const i=t,r=this.getBoneNode(i);r&&(k.copy(r.position),T.copy(r.quaternion),e[i]={position:k.toArray(),rotation:T.toArray()})})),e}getPose(){const e={};return Object.keys(this.humanBones).forEach((t=>{const i=t,r=this.getBoneNode(i);if(!r)return;k.set(0,0,0),T.identity();const o=this.restPose[i];(null==o?void 0:o.position)&&k.fromArray(o.position).negate(),(null==o?void 0:o.rotation)&&I(T.fromArray(o.rotation)),k.add(r.position),T.premultiply(r.quaternion),e[i]={position:k.toArray(),rotation:T.toArray()}})),e}setPose(e){Object.entries(e).forEach((([e,t])=>{const i=e,r=this.getBoneNode(i);if(!r)return;const o=this.restPose[i];o&&((null==t?void 0:t.position)&&(r.position.fromArray(t.position),o.position&&r.position.add(k.fromArray(o.position))),(null==t?void 0:t.rotation)&&(r.quaternion.fromArray(t.rotation),o.rotation&&r.quaternion.multiply(T.fromArray(o.rotation))))}))}resetPose(){Object.entries(this.restPose).forEach((([e,t])=>{const i=this.getBoneNode(e);i&&((null==t?void 0:t.position)&&i.position.fromArray(t.position),(null==t?void 0:t.rotation)&&i.quaternion.fromArray(t.rotation))}))}getBone(e){var t;return null!==(t=this.humanBones[e])&&void 0!==t?t:void 0}getBoneNode(e){var t,i;return null!==(i=null===(t=this.humanBones[e])||void 0===t?void 0:t.node)&&void 0!==i?i:null}}const H=new r.Vector3,D=new r.Quaternion,O=new r.Vector3;class N extends U{static _setupTransforms(e){const t=new r.Object3D;t.name="VRMHumanoidRig";const i={},o={},n={};V.forEach((t=>{var s;const a=e.getBoneNode(t);if(a){const e=new r.Vector3,l=new r.Quaternion;a.updateWorldMatrix(!0,!1),a.matrixWorld.decompose(e,l,H),i[t]=e,o[t]=a.quaternion.clone();const h=new r.Quaternion;null===(s=a.parent)||void 0===s||s.matrixWorld.decompose(H,h,H),n[t]=h}}));const s={};return V.forEach((o=>{var n;const a=e.getBoneNode(o);if(a){const e=i[o];let l,h=o;for(;null==l&&(h=B[h],null!=h);)l=i[h];const u=new r.Object3D;u.name="Normalized_"+a.name;(h?null===(n=s[h])||void 0===n?void 0:n.node:t).add(u),u.position.copy(e),l&&u.position.sub(l),s[o]={node:u}}})),{rigBones:s,root:t,parentWorldRotations:n,boneRotations:o}}constructor(e){const{rigBones:t,root:i,parentWorldRotations:r,boneRotations:o}=N._setupTransforms(e);super(t),this.original=e,this.root=i,this._parentWorldRotations=r,this._boneRotations=o}update(){V.forEach((e=>{const t=this.original.getBoneNode(e);if(null!=t){const i=this.getBoneNode(e),r=this._parentWorldRotations[e],o=D.copy(r).invert(),n=this._boneRotations[e];if(t.quaternion.copy(i.quaternion).multiply(r).premultiply(o).multiply(n),"hips"===e){const e=i.getWorldPosition(O);t.parent.updateWorldMatrix(!0,!1);const r=t.parent.matrixWorld,o=e.applyMatrix4(r.invert());t.position.copy(o)}}}))}}class F{get restPose(){return console.warn("VRMHumanoid: restPose is deprecated. Use either rawRestPose or normalizedRestPose instead."),this.rawRestPose}get rawRestPose(){return this._rawHumanBones.restPose}get normalizedRestPose(){return this._normalizedHumanBones.restPose}get humanBones(){return this._rawHumanBones.humanBones}get rawHumanBones(){return this._rawHumanBones.humanBones}get normalizedHumanBones(){return this._normalizedHumanBones.humanBones}get normalizedHumanBonesRoot(){return this._normalizedHumanBones.root}constructor(e,t){var i;this.autoUpdateHumanBones=null===(i=null==t?void 0:t.autoUpdateHumanBones)||void 0===i||i,this._rawHumanBones=new U(e),this._normalizedHumanBones=new N(this._rawHumanBones)}copy(e){return this.autoUpdateHumanBones=e.autoUpdateHumanBones,this._rawHumanBones=new U(e.humanBones),this._normalizedHumanBones=new N(this._rawHumanBones),this}clone(){return new F(this.humanBones,{autoUpdateHumanBones:this.autoUpdateHumanBones}).copy(this)}getAbsolutePose(){return console.warn("VRMHumanoid: getAbsolutePose() is deprecated. Use either getRawAbsolutePose() or getNormalizedAbsolutePose() instead."),this.getRawAbsolutePose()}getRawAbsolutePose(){return this._rawHumanBones.getAbsolutePose()}getNormalizedAbsolutePose(){return this._normalizedHumanBones.getAbsolutePose()}getPose(){return console.warn("VRMHumanoid: getPose() is deprecated. Use either getRawPose() or getNormalizedPose() instead."),this.getRawPose()}getRawPose(){return this._rawHumanBones.getPose()}getNormalizedPose(){return this._normalizedHumanBones.getPose()}setPose(e){return console.warn("VRMHumanoid: setPose() is deprecated. Use either setRawPose() or setNormalizedPose() instead."),this.setRawPose(e)}setRawPose(e){return this._rawHumanBones.setPose(e)}setNormalizedPose(e){return this._normalizedHumanBones.setPose(e)}resetPose(){return console.warn("VRMHumanoid: resetPose() is deprecated. Use either resetRawPose() or resetNormalizedPose() instead."),this.resetRawPose()}resetRawPose(){return this._rawHumanBones.resetPose()}resetNormalizedPose(){return this._normalizedHumanBones.resetPose()}getBone(e){return console.warn("VRMHumanoid: getBone() is deprecated. Use either getRawBone() or getNormalizedBone() instead."),this.getRawBone(e)}getRawBone(e){return this._rawHumanBones.getBone(e)}getNormalizedBone(e){return this._normalizedHumanBones.getBone(e)}getBoneNode(e){return console.warn("VRMHumanoid: getBoneNode() is deprecated. Use either getRawBoneNode() or getNormalizedBoneNode() instead."),this.getRawBoneNode(e)}getRawBoneNode(e){return this._rawHumanBones.getBoneNode(e)}getNormalizedBoneNode(e){return this._normalizedHumanBones.getBoneNode(e)}update(){this.autoUpdateHumanBones&&this._normalizedHumanBones.update()}}const C={Hips:"hips",Spine:"spine",Head:"head",LeftUpperLeg:"leftUpperLeg",LeftLowerLeg:"leftLowerLeg",LeftFoot:"leftFoot",RightUpperLeg:"rightUpperLeg",RightLowerLeg:"rightLowerLeg",RightFoot:"rightFoot",LeftUpperArm:"leftUpperArm",LeftLowerArm:"leftLowerArm",LeftHand:"leftHand",RightUpperArm:"rightUpperArm",RightLowerArm:"rightLowerArm",RightHand:"rightHand"},S=new Set(["1.0","1.0-beta"]),W={leftThumbProximal:"leftThumbMetacarpal",leftThumbIntermediate:"leftThumbProximal",rightThumbProximal:"rightThumbMetacarpal",rightThumbIntermediate:"rightThumbProximal"};class z{get name(){return"VRMHumanoidLoaderPlugin"}constructor(e,t){this.parser=e,this.helperRoot=null==t?void 0:t.helperRoot,this.autoUpdateHumanBones=null==t?void 0:t.autoUpdateHumanBones}afterRoot(e){return n(this,void 0,void 0,(function*(){e.userData.vrmHumanoid=yield this._import(e)}))}_import(e){return n(this,void 0,void 0,(function*(){const t=yield this._v1Import(e);if(t)return t;const i=yield this._v0Import(e);return i||null}))}_v1Import(e){var t,i;return n(this,void 0,void 0,(function*(){const r=this.parser.json;if(!(-1!==(null===(t=r.extensionsUsed)||void 0===t?void 0:t.indexOf("VRMC_vrm"))))return null;const o=null===(i=r.extensions)||void 0===i?void 0:i.VRMC_vrm;if(!o)return null;const s=o.specVersion;if(!S.has(s))return console.warn(`VRMHumanoidLoaderPlugin: Unknown VRMC_vrm specVersion "${s}"`),null;const a=o.humanoid;if(!a)return null;const l=null!=a.humanBones.leftThumbIntermediate||null!=a.humanBones.rightThumbIntermediate,h={};null!=a.humanBones&&(yield Promise.all(Object.entries(a.humanBones).map((([e,t])=>n(this,void 0,void 0,(function*(){let i=e;const r=t.node;if(l){const e=W[i];null!=e&&(i=e)}const o=yield this.parser.getDependency("node",r);null!=o?h[i]={node:o}:console.warn(`A glTF node bound to the humanoid bone ${i} (index = ${r}) does not exist`)}))))));const u=new F(this._ensureRequiredBonesExist(h),{autoUpdateHumanBones:this.autoUpdateHumanBones});if(e.scene.add(u.normalizedHumanBonesRoot),this.helperRoot){const e=new E(u);this.helperRoot.add(e),e.renderOrder=this.helperRoot.renderOrder}return u}))}_v0Import(e){var t;return n(this,void 0,void 0,(function*(){const i=this.parser.json,r=null===(t=i.extensions)||void 0===t?void 0:t.VRM;if(!r)return null;const o=r.humanoid;if(!o)return null;const s={};null!=o.humanBones&&(yield Promise.all(o.humanBones.map((e=>n(this,void 0,void 0,(function*(){const t=e.bone,i=e.node;if(null==t||null==i)return;const r=yield this.parser.getDependency("node",i);if(null==r)return void console.warn(`A glTF node bound to the humanoid bone ${t} (index = ${i}) does not exist`);const o=W[t],n=null!=o?o:t;null==s[n]?s[n]={node:r}:console.warn(`Multiple bone entries for ${n} detected (index = ${i}), ignoring duplicated entries.`)}))))));const a=new F(this._ensureRequiredBonesExist(s),{autoUpdateHumanBones:this.autoUpdateHumanBones});if(e.scene.add(a.normalizedHumanBonesRoot),this.helperRoot){const e=new E(a);this.helperRoot.add(e),e.renderOrder=this.helperRoot.renderOrder}return a}))}_ensureRequiredBonesExist(e){const t=Object.values(C).filter((t=>null==e[t]));if(t.length>0)throw new Error(`VRMHumanoidLoaderPlugin: These humanoid bones are required but not exist: ${t.join(", ")}`);return e}}class Q extends r.BufferGeometry{constructor(){super(),this._currentTheta=0,this._currentRadius=0,this.theta=0,this.radius=0,this._currentTheta=0,this._currentRadius=0,this._attrPos=new r.BufferAttribute(new Float32Array(195),3),this.setAttribute("position",this._attrPos),this._attrIndex=new r.BufferAttribute(new Uint16Array(189),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let e=!1;this._currentTheta!==this.theta&&(this._currentTheta=this.theta,e=!0),this._currentRadius!==this.radius&&(this._currentRadius=this.radius,e=!0),e&&this._buildPosition()}_buildPosition(){this._attrPos.setXYZ(0,0,0,0);for(let e=0;e<64;e++){const t=e/63*this._currentTheta;this._attrPos.setXYZ(e+1,this._currentRadius*Math.sin(t),0,this._currentRadius*Math.cos(t))}this._attrPos.needsUpdate=!0}_buildIndex(){for(let e=0;e<63;e++)this._attrIndex.setXYZ(3*e,0,e+1,e+2);this._attrIndex.needsUpdate=!0}}class j extends r.BufferGeometry{constructor(){super(),this.radius=0,this._currentRadius=0,this.tail=new r.Vector3,this._currentTail=new r.Vector3,this._attrPos=new r.BufferAttribute(new Float32Array(294),3),this.setAttribute("position",this._attrPos),this._attrIndex=new r.BufferAttribute(new Uint16Array(194),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let e=!1;this._currentRadius!==this.radius&&(this._currentRadius=this.radius,e=!0),this._currentTail.equals(this.tail)||(this._currentTail.copy(this.tail),e=!0),e&&this._buildPosition()}_buildPosition(){for(let e=0;e<32;e++){const t=e/16*Math.PI;this._attrPos.setXYZ(e,Math.cos(t),Math.sin(t),0),this._attrPos.setXYZ(32+e,0,Math.cos(t),Math.sin(t)),this._attrPos.setXYZ(64+e,Math.sin(t),0,Math.cos(t))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.setXYZ(96,0,0,0),this._attrPos.setXYZ(97,this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let e=0;e<32;e++){const t=(e+1)%32;this._attrIndex.setXY(2*e,e,t),this._attrIndex.setXY(64+2*e,32+e,32+t),this._attrIndex.setXY(128+2*e,64+e,64+t)}this._attrIndex.setXY(192,96,97),this._attrIndex.needsUpdate=!0}}const Y=new r.Quaternion,$=new r.Quaternion,q=new r.Vector3,G=new r.Vector3,X=Math.sqrt(2)/2,Z=new r.Quaternion(0,0,-X,X),J=new r.Vector3(0,1,0);class K extends r.Group{constructor(e){super(),this.matrixAutoUpdate=!1,this.vrmLookAt=e;{const e=new Q;e.radius=.5;const t=new r.MeshBasicMaterial({color:65280,transparent:!0,opacity:.5,side:r.DoubleSide,depthTest:!1,depthWrite:!1});this._meshPitch=new r.Mesh(e,t),this.add(this._meshPitch)}{const e=new Q;e.radius=.5;const t=new r.MeshBasicMaterial({color:16711680,transparent:!0,opacity:.5,side:r.DoubleSide,depthTest:!1,depthWrite:!1});this._meshYaw=new r.Mesh(e,t),this.add(this._meshYaw)}{const e=new j;e.radius=.1;const t=new r.LineBasicMaterial({color:16777215,depthTest:!1,depthWrite:!1});this._lineTarget=new r.LineSegments(e,t),this._lineTarget.frustumCulled=!1,this.add(this._lineTarget)}}dispose(){this._meshYaw.geometry.dispose(),this._meshYaw.material.dispose(),this._meshPitch.geometry.dispose(),this._meshPitch.material.dispose(),this._lineTarget.geometry.dispose(),this._lineTarget.material.dispose()}updateMatrixWorld(e){const t=r.MathUtils.DEG2RAD*this.vrmLookAt.yaw;this._meshYaw.geometry.theta=t,this._meshYaw.geometry.update();const i=r.MathUtils.DEG2RAD*this.vrmLookAt.pitch;this._meshPitch.geometry.theta=i,this._meshPitch.geometry.update(),this.vrmLookAt.getLookAtWorldPosition(q),this.vrmLookAt.getLookAtWorldQuaternion(Y),Y.multiply(this.vrmLookAt.getFaceFrontQuaternion($)),this._meshYaw.position.copy(q),this._meshYaw.quaternion.copy(Y),this._meshPitch.position.copy(q),this._meshPitch.quaternion.copy(Y),this._meshPitch.quaternion.multiply($.setFromAxisAngle(J,t)),this._meshPitch.quaternion.multiply(Z);const{target:o,autoUpdate:n}=this.vrmLookAt;null!=o&&n&&(o.getWorldPosition(G).sub(q),this._lineTarget.geometry.tail.copy(G),this._lineTarget.geometry.update(),this._lineTarget.position.copy(q)),super.updateMatrixWorld(e)}}const ee=new r.Vector3,te=new r.Vector3;function ie(e,t){return e.matrixWorld.decompose(ee,t,te),t}function re(e){return[Math.atan2(-e.z,e.x),Math.atan2(e.y,Math.sqrt(e.x*e.x+e.z*e.z))]}function oe(e){const t=Math.round(e/2/Math.PI);return e-2*Math.PI*t}const ne=new r.Vector3(0,0,1),se=new r.Vector3,ae=new r.Vector3,le=new r.Vector3,he=new r.Quaternion,ue=new r.Quaternion,de=new r.Quaternion,pe=new r.Quaternion,ce=new r.Euler;class me{get yaw(){return this._yaw}set yaw(e){this._yaw=e,this._needsUpdate=!0}get pitch(){return this._pitch}set pitch(e){this._pitch=e,this._needsUpdate=!0}get euler(){return console.warn("VRMLookAt: euler is deprecated. use getEuler() instead."),this.getEuler(new r.Euler)}constructor(e,t){this.offsetFromHeadBone=new r.Vector3,this.autoUpdate=!0,this.faceFront=new r.Vector3(0,0,1),this.humanoid=e,this.applier=t,this._yaw=0,this._pitch=0,this._needsUpdate=!0,this._restHeadWorldQuaternion=this.getLookAtWorldQuaternion(new r.Quaternion)}getEuler(e){return e.set(r.MathUtils.DEG2RAD*this._pitch,r.MathUtils.DEG2RAD*this._yaw,0,"YXZ")}copy(e){if(this.humanoid!==e.humanoid)throw new Error("VRMLookAt: humanoid must be same in order to copy");return this.offsetFromHeadBone.copy(e.offsetFromHeadBone),this.applier=e.applier,this.autoUpdate=e.autoUpdate,this.target=e.target,this.faceFront.copy(e.faceFront),this}clone(){return new me(this.humanoid,this.applier).copy(this)}reset(){this._yaw=0,this._pitch=0,this._needsUpdate=!0}getLookAtWorldPosition(e){const t=this.humanoid.getRawBoneNode("head");return e.copy(this.offsetFromHeadBone).applyMatrix4(t.matrixWorld)}getLookAtWorldQuaternion(e){return ie(this.humanoid.getRawBoneNode("head"),e)}getFaceFrontQuaternion(e){if(this.faceFront.distanceToSquared(ne)<.01)return e.copy(this._restHeadWorldQuaternion).invert();const[t,i]=re(this.faceFront);return ce.set(0,.5*Math.PI+t,i,"YZX"),e.setFromEuler(ce).premultiply(pe.copy(this._restHeadWorldQuaternion).invert())}getLookAtWorldDirection(e){return this.getLookAtWorldQuaternion(ue),this.getFaceFrontQuaternion(de),e.copy(ne).applyQuaternion(ue).applyQuaternion(de).applyEuler(this.getEuler(ce))}lookAt(e){const t=he.copy(this._restHeadWorldQuaternion).multiply(I(this.getLookAtWorldQuaternion(ue))),i=this.getLookAtWorldPosition(ae),o=le.copy(e).sub(i).applyQuaternion(t).normalize(),[n,s]=re(this.faceFront),[a,l]=re(o),h=oe(a-n),u=oe(s-l);this._yaw=r.MathUtils.RAD2DEG*h,this._pitch=r.MathUtils.RAD2DEG*u,this._needsUpdate=!0}update(e){null!=this.target&&this.autoUpdate&&this.lookAt(this.target.getWorldPosition(se)),this._needsUpdate&&(this._needsUpdate=!1,this.applier.applyYawPitch(this._yaw,this._pitch))}}me.EULER_ORDER="YXZ";const ge=new r.Vector3(0,0,1),fe=new r.Quaternion,ve=new r.Quaternion,ye=new r.Euler(0,0,0,"YXZ");class Me{constructor(e,t,i,o,n){this.humanoid=e,this.rangeMapHorizontalInner=t,this.rangeMapHorizontalOuter=i,this.rangeMapVerticalDown=o,this.rangeMapVerticalUp=n,this.faceFront=new r.Vector3(0,0,1),this._restQuatLeftEye=new r.Quaternion,this._restQuatRightEye=new r.Quaternion,this._restLeftEyeParentWorldQuat=new r.Quaternion,this._restRightEyeParentWorldQuat=new r.Quaternion;const s=this.humanoid.getRawBoneNode("leftEye"),a=this.humanoid.getRawBoneNode("rightEye");s&&(this._restQuatLeftEye.copy(s.quaternion),ie(s.parent,this._restLeftEyeParentWorldQuat)),a&&(this._restQuatRightEye.copy(a.quaternion),ie(a.parent,this._restRightEyeParentWorldQuat))}applyYawPitch(e,t){const i=this.humanoid.getRawBoneNode("leftEye"),o=this.humanoid.getRawBoneNode("rightEye"),n=this.humanoid.getNormalizedBoneNode("leftEye"),s=this.humanoid.getNormalizedBoneNode("rightEye");i&&(ye.x=t<0?-r.MathUtils.DEG2RAD*this.rangeMapVerticalDown.map(-t):r.MathUtils.DEG2RAD*this.rangeMapVerticalUp.map(t),ye.y=e<0?-r.MathUtils.DEG2RAD*this.rangeMapHorizontalInner.map(-e):r.MathUtils.DEG2RAD*this.rangeMapHorizontalOuter.map(e),fe.setFromEuler(ye),this._getWorldFaceFrontQuat(ve),n.quaternion.copy(ve).multiply(fe).multiply(ve.invert()),fe.copy(this._restLeftEyeParentWorldQuat),i.quaternion.copy(n.quaternion).multiply(fe).premultiply(fe.invert()).multiply(this._restQuatLeftEye)),o&&(ye.x=t<0?-r.MathUtils.DEG2RAD*this.rangeMapVerticalDown.map(-t):r.MathUtils.DEG2RAD*this.rangeMapVerticalUp.map(t),ye.y=e<0?-r.MathUtils.DEG2RAD*this.rangeMapHorizontalOuter.map(-e):r.MathUtils.DEG2RAD*this.rangeMapHorizontalInner.map(e),fe.setFromEuler(ye),this._getWorldFaceFrontQuat(ve),s.quaternion.copy(ve).multiply(fe).multiply(ve.invert()),fe.copy(this._restRightEyeParentWorldQuat),o.quaternion.copy(s.quaternion).multiply(fe).premultiply(fe.invert()).multiply(this._restQuatRightEye))}lookAt(e){console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");const t=r.MathUtils.RAD2DEG*e.y,i=r.MathUtils.RAD2DEG*e.x;this.applyYawPitch(t,i)}_getWorldFaceFrontQuat(e){if(this.faceFront.distanceToSquared(ge)<.01)return e.identity();const[t,i]=re(this.faceFront);return ye.set(0,.5*Math.PI+t,i,"YZX"),e.setFromEuler(ye)}}Me.type="bone";class xe{constructor(e,t,i,r,o){this.expressions=e,this.rangeMapHorizontalInner=t,this.rangeMapHorizontalOuter=i,this.rangeMapVerticalDown=r,this.rangeMapVerticalUp=o}applyYawPitch(e,t){t<0?(this.expressions.setValue("lookDown",0),this.expressions.setValue("lookUp",this.rangeMapVerticalUp.map(-t))):(this.expressions.setValue("lookUp",0),this.expressions.setValue("lookDown",this.rangeMapVerticalDown.map(t))),e<0?(this.expressions.setValue("lookLeft",0),this.expressions.setValue("lookRight",this.rangeMapHorizontalOuter.map(-e))):(this.expressions.setValue("lookRight",0),this.expressions.setValue("lookLeft",this.rangeMapHorizontalOuter.map(e)))}lookAt(e){console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");const t=r.MathUtils.RAD2DEG*e.y,i=r.MathUtils.RAD2DEG*e.x;this.applyYawPitch(t,i)}}xe.type="expression";class we{constructor(e,t){this.inputMaxValue=e,this.outputScale=t}map(e){return this.outputScale*d(e/this.inputMaxValue)}}const _e=new Set(["1.0","1.0-beta"]),Re=.01;class Pe{get name(){return"VRMLookAtLoaderPlugin"}constructor(e,t){this.parser=e,this.helperRoot=null==t?void 0:t.helperRoot}afterRoot(e){return n(this,void 0,void 0,(function*(){const t=e.userData.vrmHumanoid;if(null===t)return;if(void 0===t)throw new Error("VRMLookAtLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");const i=e.userData.vrmExpressionManager;if(null!==i){if(void 0===i)throw new Error("VRMLookAtLoaderPlugin: vrmExpressionManager is undefined. VRMExpressionLoaderPlugin have to be used first");e.userData.vrmLookAt=yield this._import(e,t,i)}}))}_import(e,t,i){return n(this,void 0,void 0,(function*(){if(null==t||null==i)return null;const r=yield this._v1Import(e,t,i);if(r)return r;const o=yield this._v0Import(e,t,i);return o||null}))}_v1Import(e,t,i){var r,o,s;return n(this,void 0,void 0,(function*(){const e=this.parser.json;if(!(-1!==(null===(r=e.extensionsUsed)||void 0===r?void 0:r.indexOf("VRMC_vrm"))))return null;const n=null===(o=e.extensions)||void 0===o?void 0:o.VRMC_vrm;if(!n)return null;const a=n.specVersion;if(!_e.has(a))return console.warn(`VRMLookAtLoaderPlugin: Unknown VRMC_vrm specVersion "${a}"`),null;const l=n.lookAt;if(!l)return null;const h="expression"===l.type?1:10,u=this._v1ImportRangeMap(l.rangeMapHorizontalInner,h),d=this._v1ImportRangeMap(l.rangeMapHorizontalOuter,h),p=this._v1ImportRangeMap(l.rangeMapVerticalDown,h),c=this._v1ImportRangeMap(l.rangeMapVerticalUp,h);let m;m="expression"===l.type?new xe(i,u,d,p,c):new Me(t,u,d,p,c);const g=this._importLookAt(t,m);return g.offsetFromHeadBone.fromArray(null!==(s=l.offsetFromHeadBone)&&void 0!==s?s:[0,.06,0]),g}))}_v1ImportRangeMap(e,t){var i,r;let o=null!==(i=null==e?void 0:e.inputMaxValue)&&void 0!==i?i:90;const n=null!==(r=null==e?void 0:e.outputScale)&&void 0!==r?r:t;return o<Re&&(console.warn("VRMLookAtLoaderPlugin: inputMaxValue of a range map is too small. Consider reviewing the range map!"),o=Re),new we(o,n)}_v0Import(e,t,i){var r,o,s,a;return n(this,void 0,void 0,(function*(){const e=this.parser.json,n=null===(r=e.extensions)||void 0===r?void 0:r.VRM;if(!n)return null;const l=n.firstPerson;if(!l)return null;const h="BlendShape"===l.lookAtTypeName?1:10,u=this._v0ImportDegreeMap(l.lookAtHorizontalInner,h),d=this._v0ImportDegreeMap(l.lookAtHorizontalOuter,h),p=this._v0ImportDegreeMap(l.lookAtVerticalDown,h),c=this._v0ImportDegreeMap(l.lookAtVerticalUp,h);let m;m="BlendShape"===l.lookAtTypeName?new xe(i,u,d,p,c):new Me(t,u,d,p,c);const g=this._importLookAt(t,m);return l.firstPersonBoneOffset?g.offsetFromHeadBone.set(null!==(o=l.firstPersonBoneOffset.x)&&void 0!==o?o:0,null!==(s=l.firstPersonBoneOffset.y)&&void 0!==s?s:.06,-(null!==(a=l.firstPersonBoneOffset.z)&&void 0!==a?a:0)):g.offsetFromHeadBone.set(0,.06,0),g.faceFront.set(0,0,-1),m instanceof Me&&m.faceFront.set(0,0,-1),g}))}_v0ImportDegreeMap(e,t){var i,r;const o=null==e?void 0:e.curve;"[0,0,0,1,1,1,1,0]"!==JSON.stringify(o)&&console.warn("Curves of LookAtDegreeMap defined in VRM 0.0 are not supported");let n=null!==(i=null==e?void 0:e.xRange)&&void 0!==i?i:90;const s=null!==(r=null==e?void 0:e.yRange)&&void 0!==r?r:t;return n<Re&&(console.warn("VRMLookAtLoaderPlugin: xRange of a degree map is too small. Consider reviewing the degree map!"),n=Re),new we(n,s)}_importLookAt(e,t){const i=new me(e,t);if(this.helperRoot){const e=new K(i);this.helperRoot.add(e),e.renderOrder=this.helperRoot.renderOrder}return i}}const Le=new Set(["1.0","1.0-beta"]);class Ae{get name(){return"VRMMetaLoaderPlugin"}constructor(e,t){var i,r,o;this.parser=e,this.needThumbnailImage=null===(i=null==t?void 0:t.needThumbnailImage)||void 0===i||i,this.acceptLicenseUrls=null!==(r=null==t?void 0:t.acceptLicenseUrls)&&void 0!==r?r:["https://vrm.dev/licenses/1.0/"],this.acceptV0Meta=null===(o=null==t?void 0:t.acceptV0Meta)||void 0===o||o}afterRoot(e){return n(this,void 0,void 0,(function*(){e.userData.vrmMeta=yield this._import(e)}))}_import(e){return n(this,void 0,void 0,(function*(){const t=yield this._v1Import(e);if(null!=t)return t;const i=yield this._v0Import(e);return null!=i?i:null}))}_v1Import(e){var t,i,r;return n(this,void 0,void 0,(function*(){const e=this.parser.json;if(!(-1!==(null===(t=e.extensionsUsed)||void 0===t?void 0:t.indexOf("VRMC_vrm"))))return null;const o=null===(i=e.extensions)||void 0===i?void 0:i.VRMC_vrm;if(null==o)return null;const n=o.specVersion;if(!Le.has(n))return console.warn(`VRMMetaLoaderPlugin: Unknown VRMC_vrm specVersion "${n}"`),null;const s=o.meta;if(!s)return null;const a=s.licenseUrl;if(!new Set(this.acceptLicenseUrls).has(a))throw new Error(`VRMMetaLoaderPlugin: The license url "${a}" is not accepted`);let l;return this.needThumbnailImage&&null!=s.thumbnailImage&&(l=null!==(r=yield this._extractGLTFImage(s.thumbnailImage))&&void 0!==r?r:void 0),{metaVersion:"1",name:s.name,version:s.version,authors:s.authors,copyrightInformation:s.copyrightInformation,contactInformation:s.contactInformation,references:s.references,thirdPartyLicenses:s.thirdPartyLicenses,thumbnailImage:l,licenseUrl:s.licenseUrl,avatarPermission:s.avatarPermission,allowExcessivelyViolentUsage:s.allowExcessivelyViolentUsage,allowExcessivelySexualUsage:s.allowExcessivelySexualUsage,commercialUsage:s.commercialUsage,allowPoliticalOrReligiousUsage:s.allowPoliticalOrReligiousUsage,allowAntisocialOrHateUsage:s.allowAntisocialOrHateUsage,creditNotation:s.creditNotation,allowRedistribution:s.allowRedistribution,modification:s.modification,otherLicenseUrl:s.otherLicenseUrl}}))}_v0Import(e){var t;return n(this,void 0,void 0,(function*(){const e=this.parser.json,i=null===(t=e.extensions)||void 0===t?void 0:t.VRM;if(!i)return null;const r=i.meta;if(!r)return null;if(!this.acceptV0Meta)throw new Error("VRMMetaLoaderPlugin: Attempted to load VRM0.0 meta but acceptV0Meta is false");let o;return this.needThumbnailImage&&null!=r.texture&&-1!==r.texture&&(o=yield this.parser.getDependency("texture",r.texture)),{metaVersion:"0",allowedUserName:r.allowedUserName,author:r.author,commercialUssageName:r.commercialUssageName,contactInformation:r.contactInformation,licenseName:r.licenseName,otherLicenseUrl:r.otherLicenseUrl,otherPermissionUrl:r.otherPermissionUrl,reference:r.reference,sexualUssageName:r.sexualUssageName,texture:null!=o?o:void 0,title:r.title,version:r.version,violentUssageName:r.violentUssageName}}))}_extractGLTFImage(e){var t;return n(this,void 0,void 0,(function*(){const i=this.parser.json,o=null===(t=i.images)||void 0===t?void 0:t[e];if(null==o)return console.warn(`VRMMetaLoaderPlugin: Attempt to use images[${e}] of glTF as a thumbnail but the image doesn't exist`),null;let n=o.uri;if(null!=o.bufferView){const e=yield this.parser.getDependency("bufferView",o.bufferView),t=new Blob([e],{type:o.mimeType});n=URL.createObjectURL(t)}if(null==n)return console.warn(`VRMMetaLoaderPlugin: Attempt to use images[${e}] of glTF as a thumbnail but the image couldn't load properly`),null;const s=new r.ImageLoader;return yield s.loadAsync((a=n,l=this.parser.options.path,"string"!=typeof a||""===a?"":(/^https?:\/\//i.test(l)&&/^\//.test(a)&&(l=l.replace(/(^https?:\/\/[^/]+).*/i,"$1")),/^(https?:)?\/\//i.test(a)||/^data:.*,.*$/i.test(a)||/^blob:.*$/i.test(a)?a:l+a))).catch((e=>(console.error(e),console.warn("VRMMetaLoaderPlugin: Failed to load a thumbnail image"),null)));var a,l}))}}class be{constructor(e){this.scene=e.scene,this.meta=e.meta,this.humanoid=e.humanoid,this.expressionManager=e.expressionManager,this.firstPerson=e.firstPerson,this.lookAt=e.lookAt}update(e){this.humanoid.update(),this.lookAt&&this.lookAt.update(e),this.expressionManager&&this.expressionManager.update()}}e.VRMCore=be,e.VRMCoreLoaderPlugin=class{get name(){return"VRMC_vrm"}constructor(e,t){var i,r,o,n,s;this.parser=e;const a=null==t?void 0:t.helperRoot,l=null==t?void 0:t.autoUpdateHumanBones;this.expressionPlugin=null!==(i=null==t?void 0:t.expressionPlugin)&&void 0!==i?i:new w(e),this.firstPersonPlugin=null!==(r=null==t?void 0:t.firstPersonPlugin)&&void 0!==r?r:new P(e),this.humanoidPlugin=null!==(o=null==t?void 0:t.humanoidPlugin)&&void 0!==o?o:new z(e,{helperRoot:a,autoUpdateHumanBones:l}),this.lookAtPlugin=null!==(n=null==t?void 0:t.lookAtPlugin)&&void 0!==n?n:new Pe(e,{helperRoot:a}),this.metaPlugin=null!==(s=null==t?void 0:t.metaPlugin)&&void 0!==s?s:new Ae(e)}afterRoot(e){return n(this,void 0,void 0,(function*(){yield this.metaPlugin.afterRoot(e),yield this.humanoidPlugin.afterRoot(e),yield this.expressionPlugin.afterRoot(e),yield this.lookAtPlugin.afterRoot(e),yield this.firstPersonPlugin.afterRoot(e);const t=e.userData.vrmMeta,i=e.userData.vrmHumanoid;if(t&&i){const r=new be({scene:e.scene,expressionManager:e.userData.vrmExpressionManager,firstPerson:e.userData.vrmFirstPerson,humanoid:i,lookAt:e.userData.vrmLookAt,meta:t});e.userData.vrmCore=r}}))}},e.VRMExpression=o,e.VRMExpressionLoaderPlugin=w,e.VRMExpressionManager=p,e.VRMExpressionMaterialColorBind=f,e.VRMExpressionMaterialColorType=c,e.VRMExpressionMorphTargetBind=v,e.VRMExpressionOverrideType={None:"none",Block:"block",Blend:"blend"},e.VRMExpressionPresetName=u,e.VRMExpressionTextureTransformBind=M,e.VRMFirstPerson=_,e.VRMFirstPersonLoaderPlugin=P,e.VRMFirstPersonMeshAnnotationType={Auto:"auto",Both:"both",ThirdPersonOnly:"thirdPersonOnly",FirstPersonOnly:"firstPersonOnly"},e.VRMHumanBoneList=V,e.VRMHumanBoneName={Hips:"hips",Spine:"spine",Chest:"chest",UpperChest:"upperChest",Neck:"neck",Head:"head",LeftEye:"leftEye",RightEye:"rightEye",Jaw:"jaw",LeftUpperLeg:"leftUpperLeg",LeftLowerLeg:"leftLowerLeg",LeftFoot:"leftFoot",LeftToes:"leftToes",RightUpperLeg:"rightUpperLeg",RightLowerLeg:"rightLowerLeg",RightFoot:"rightFoot",RightToes:"rightToes",LeftShoulder:"leftShoulder",LeftUpperArm:"leftUpperArm",LeftLowerArm:"leftLowerArm",LeftHand:"leftHand",RightShoulder:"rightShoulder",RightUpperArm:"rightUpperArm",RightLowerArm:"rightLowerArm",RightHand:"rightHand",LeftThumbMetacarpal:"leftThumbMetacarpal",LeftThumbProximal:"leftThumbProximal",LeftThumbDistal:"leftThumbDistal",LeftIndexProximal:"leftIndexProximal",LeftIndexIntermediate:"leftIndexIntermediate",LeftIndexDistal:"leftIndexDistal",LeftMiddleProximal:"leftMiddleProximal",LeftMiddleIntermediate:"leftMiddleIntermediate",LeftMiddleDistal:"leftMiddleDistal",LeftRingProximal:"leftRingProximal",LeftRingIntermediate:"leftRingIntermediate",LeftRingDistal:"leftRingDistal",LeftLittleProximal:"leftLittleProximal",LeftLittleIntermediate:"leftLittleIntermediate",LeftLittleDistal:"leftLittleDistal",RightThumbMetacarpal:"rightThumbMetacarpal",RightThumbProximal:"rightThumbProximal",RightThumbDistal:"rightThumbDistal",RightIndexProximal:"rightIndexProximal",RightIndexIntermediate:"rightIndexIntermediate",RightIndexDistal:"rightIndexDistal",RightMiddleProximal:"rightMiddleProximal",RightMiddleIntermediate:"rightMiddleIntermediate",RightMiddleDistal:"rightMiddleDistal",RightRingProximal:"rightRingProximal",RightRingIntermediate:"rightRingIntermediate",RightRingDistal:"rightRingDistal",RightLittleProximal:"rightLittleProximal",RightLittleIntermediate:"rightLittleIntermediate",RightLittleDistal:"rightLittleDistal"},e.VRMHumanBoneParentMap=B,e.VRMHumanoid=F,e.VRMHumanoidHelper=E,e.VRMHumanoidLoaderPlugin=z,e.VRMLookAt=me,e.VRMLookAtBoneApplier=Me,e.VRMLookAtExpressionApplier=xe,e.VRMLookAtHelper=K,e.VRMLookAtLoaderPlugin=Pe,e.VRMLookAtRangeMap=we,e.VRMLookAtTypeName={Bone:"bone",Expression:"expression"},e.VRMMetaLoaderPlugin=Ae,e.VRMRequiredHumanBoneName=C,Object.defineProperty(e,"__esModule",{value:!0}),Object.assign(t,e)}));
